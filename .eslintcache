[{"D:\\ReactProjects\\lite-lineage\\src\\index.js":"1","D:\\ReactProjects\\lite-lineage\\src\\App.js":"2","D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js":"3","D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx":"4","D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx":"5","D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx":"6","D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx":"7","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx":"8","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx":"9","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx":"10","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx":"11","D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx":"12","D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js":"13","D:\\ReactProjects\\lite-lineage\\src\\Person.js":"14","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx":"15","D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx":"16","D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js":"17","D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx":"18","D:\\ReactProjects\\lite-lineage\\src\\Helpers.js":"19","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx":"20","D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx":"21","D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx":"22","D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js":"23","D:\\ReactProjects\\lite-lineage\\src\\components\\Notice.jsx":"24"},{"size":500,"mtime":499162500000,"results":"25","hashOfConfig":"26"},{"size":11277,"mtime":1611509246295,"results":"27","hashOfConfig":"26"},{"size":362,"mtime":499162500000,"results":"28","hashOfConfig":"26"},{"size":498,"mtime":1611498369513,"results":"29","hashOfConfig":"26"},{"size":2305,"mtime":1610568177174,"results":"30","hashOfConfig":"26"},{"size":632,"mtime":1611509562555,"results":"31","hashOfConfig":"26"},{"size":3127,"mtime":1611501513125,"results":"32","hashOfConfig":"26"},{"size":9106,"mtime":1611242978479,"results":"33","hashOfConfig":"26"},{"size":3867,"mtime":1611432423577,"results":"34","hashOfConfig":"26"},{"size":612,"mtime":1611498253521,"results":"35","hashOfConfig":"26"},{"size":1139,"mtime":1611498322843,"results":"36","hashOfConfig":"26"},{"size":1397,"mtime":1610649766940,"results":"37","hashOfConfig":"26"},{"size":8604,"mtime":1611159951168,"results":"38","hashOfConfig":"26"},{"size":6896,"mtime":1611498198308,"results":"39","hashOfConfig":"26"},{"size":12494,"mtime":1611498104796,"results":"40","hashOfConfig":"26"},{"size":1850,"mtime":1611498297626,"results":"41","hashOfConfig":"26"},{"size":296,"mtime":1611498484830,"results":"42","hashOfConfig":"26"},{"size":5468,"mtime":1611498272986,"results":"43","hashOfConfig":"26"},{"size":2694,"mtime":1611497164361,"results":"44","hashOfConfig":"26"},{"size":3205,"mtime":1611495263805,"results":"45","hashOfConfig":"26"},{"size":260,"mtime":1611498417865,"results":"46","hashOfConfig":"26"},{"size":1076,"mtime":1611438985631,"results":"47","hashOfConfig":"26"},{"size":14215,"mtime":1611494936093,"results":"48","hashOfConfig":"49"},{"size":762,"mtime":1611509507278,"results":"50","hashOfConfig":"26"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},"19gfp4v",{"filePath":"54","messages":"55","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"53"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"53"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"82","messages":"83","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"53"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101","usedDeprecatedRules":"102"},"16qv85j",{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\ReactProjects\\lite-lineage\\src\\index.js",[],["105","106"],"D:\\ReactProjects\\lite-lineage\\src\\App.js",["107","108","109","110","111"],"D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx",["112","113","114","115","116","117"],"import React, { Component } from 'react';\r\nimport SideDrawer from './SideDrawer';\r\nimport FamilyMember from './FamilyMember';\r\nimport SideDrawerEditMemberForm from './SideDrawerEditMemberForm';\r\nimport '../App.css';\r\nimport TreeContext from '../TreeContext';\r\nimport Person from '../Person';\r\nimport Helpers from '../Helpers';\r\nimport ConnectionRenderer from './ConnectionRenderer';\r\nimport FamilyConnection from './FamilyConnection';\r\n\r\nclass FamilyView extends Component\r\n{\r\n    static contextType = TreeContext;\r\n    #zoomMin = 0;\r\n    #zoomMax = 4;\r\n    #locationScalesByZoom = [20, 30, 40, 60, 80];\r\n    #lineCenteringOffsetByZoom = [\r\n        {x: 40, y: 20},\r\n        {x: 60, y: 30},\r\n        {x: 80, y: 40},\r\n        {x: 120, y: 60},\r\n        {x: 160, y: 80}\r\n    ];\r\n\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            editingPerson: false,\r\n            editedPersonId: null,\r\n            zoomLvl: 2,\r\n            locationScale: 40,\r\n            stretcherOverhead: {x: 7, y: 5},\r\n            isDragging: false,\r\n            draggedId: null,\r\n            lineCenteringOffset: {x: 80, y: 40},\r\n        }\r\n        this.startEdit = this.startEdit.bind(this);\r\n        this.reportDeletionToEdit = this.reportDeletionToEdit.bind(this);\r\n        this.endEdit = this.endEdit.bind(this);\r\n        this.startDrag = this.startDrag.bind(this);\r\n        this.tryDrag = this.tryDrag.bind(this);\r\n        this.endDrag = this.endDrag.bind(this);\r\n        this.zoom = this.zoom.bind(this);\r\n    }\r\n\r\n    startEdit(personId)\r\n    {\r\n        this.setState({editingPerson: true, editedPersonId: personId});\r\n    }\r\n\r\n    reportDeletionToEdit(personId)\r\n    {\r\n        if (this.state.editingPerson === true && this.state.editedPersonId != null && personId == this.state.editedPersonId)\r\n        {\r\n            this.endEdit();\r\n        }\r\n    }\r\n\r\n    endEdit()\r\n    {\r\n        this.setState({editingPerson: false, editedPersonId: null});\r\n    }\r\n\r\n    startDrag(personId)\r\n    {\r\n        // console.log(\"starting drag\");\r\n        this.setState({isDragging: true, draggedId: personId});\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        window.addEventListener(\"mouseup\", this.endDrag);\r\n    }\r\n\r\n    componentWillUnmount()\r\n    {\r\n        window.removeEventListener(\"mouseup\", this.endDrag);\r\n    }\r\n\r\n    tryDrag(e, referenceElement)\r\n    {\r\n        //this was the only solution that calculated coords correctly, but it needs a ref element passed somehow\r\n        const offset = Helpers.getRelativeCoords(e.nativeEvent, referenceElement);\r\n        // console.log(\"dragging \"+ this.state.draggedId +\" to [\" + offset.x + \", \" + offset.y + \"]\");\r\n        if (this.state.isDragging === true && this.state.draggedId != null && this.state.draggedId >= 0)\r\n        {\r\n            const newLocation = this.calcLocationFromOffset(offset);\r\n            const i = this.context.currentTree.family.findIndex(item => item.id == this.state.draggedId);\r\n            const draftPerson = Person.cloneFromOther(this.context.currentTree.family[i]);\r\n            // console.log(\"new location: [\" + newLocation.x + \", \" + newLocation.y + \"]\");\r\n            draftPerson.locationInTreeX = newLocation.x;\r\n            draftPerson.locationInTreeY = newLocation.y;\r\n            this.context.familyHandlers.handleEditFamMember(this.state.draggedId, draftPerson);\r\n        }\r\n    }\r\n\r\n    endDrag()\r\n    {\r\n        // console.log(\"ending drag\");\r\n        this.setState({isDragging: false, draggedId: null});\r\n    }\r\n\r\n    calcLocationFromOffset(offset)\r\n    {\r\n        return {\r\n            x: Math.round(offset.x / this.state.locationScale),\r\n            y: Math.round(offset.y / this.state.locationScale)\r\n        };\r\n    }\r\n\r\n    calcCssSizeOfConnectionRenderer()\r\n    {\r\n        //bounds of the tree incremented by 2 in both axis, so the line renderer also acts as a stretcher\r\n        //for the whole area of the tree\r\n        const bounds = this.context.currentTree.getBounds(this.state.stretcherOverhead.x, this.state.stretcherOverhead.y);\r\n        return {\r\n            width: (bounds.x * this.state.locationScale) + \"px\",\r\n            height: (bounds.y * this.state.locationScale) + \"px\"\r\n        };\r\n    }\r\n\r\n    zoom(dir)\r\n    {\r\n        if (dir == 0){return;}\r\n        dir = (dir > 0) ? 1 : -1;\r\n        this.setState((prevState, props) => (\r\n            {\r\n                zoomLvl: prevState.zoomLvl + dir,\r\n                locationScale: this.#locationScalesByZoom[prevState.zoomLvl + dir],\r\n                lineCenteringOffset: this.#lineCenteringOffsetByZoom[prevState.zoomLvl + dir]\r\n            }\r\n        ));\r\n    }\r\n    \r\n    render()\r\n    {\r\n        const familyMembers = this.context.currentTree.family.map((member) =>\r\n            <FamilyMember\r\n                key={member.id}\r\n                person={member}\r\n                familyHandlers={this.context.familyHandlers}\r\n                reportDeletionToEdit={this.reportDeletionToEdit}\r\n                startEdit={this.startEdit}\r\n                locationScale={this.state.locationScale}\r\n                zoomLvl={this.state.zoomLvl}\r\n                startDrag={this.startDrag}\r\n            />\r\n        );\r\n\r\n        //finding people taking part in a connection\r\n        const connectionMembers = [];\r\n        const establishedParentIdPairs = [];\r\n        for (let i = 0; i < this.context.currentTree.family.length; i++)\r\n        {\r\n            const b = this.context.currentTree.family[i];\r\n            const parents = b.getCurrentParents(this.context.currentTree.family);\r\n            if (parents[0] || parents[1])\r\n            {\r\n                //there is a connection that exists for b\r\n                connectionMembers.push({\r\n                    a1: parents[0],\r\n                    a2: parents[1],\r\n                    b: b\r\n                });\r\n\r\n                if (parents[0] && parents[1])\r\n                {\r\n                    //check if this parent pair was already established (checking both orders of being saved since they might differ in different child)\r\n                    //we're doing it in order not to duplicate connections that are suppoosed to represent relationships between 2 people that had children together\r\n                    //since they are distinct from the child-parent connections \r\n                    if (!establishedParentIdPairs.includes(parents[0].id + \"_\" + parents[1].id) && !establishedParentIdPairs.includes(parents[1].id + \"_\" + parents[0].id))\r\n                    {\r\n                        connectionMembers.push({\r\n                            a1: parents[0],\r\n                            a2: parents[1],\r\n                            b: null\r\n                        });\r\n                        establishedParentIdPairs.push(parents[0].id + \"_\" + parents[1].id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const connections = connectionMembers.map((connectionMember) =>\r\n            <FamilyConnection\r\n                key={connectionMember.a1?.id + \"_\" + connectionMember.a2?.id + \"|\" + connectionMember.b?.id}\r\n                personA1={connectionMember.a1}\r\n                personA2={connectionMember.a2}\r\n                personB={connectionMember.b}\r\n                locationScale={this.state.locationScale}\r\n                lineCenteringOffset={this.state.lineCenteringOffset}\r\n            />\r\n        );\r\n\r\n        const editedPersonIndex = this.context.currentTree.family.findIndex(item => item.id == this.state.editedPersonId);\r\n        const editedPerson = (editedPersonIndex >= 0) ? this.context.currentTree.family[editedPersonIndex] : null;\r\n\r\n        const sideDrawer = (\r\n            <SideDrawer\r\n                name=\"Editing...\"\r\n                content={\r\n                    <SideDrawerEditMemberForm\r\n                        editedPerson={editedPerson}\r\n                        handleEdit={this.context.familyHandlers.handleEditFamMember}\r\n                        handleEditMultiple={this.context.familyHandlers.handleEditFamMembers}\r\n                        family={this.context.currentTree.family}\r\n                    />}\r\n                closeAction={this.endEdit}\r\n            />\r\n        );\r\n\r\n        return (\r\n            <div className=\"family_view\">\r\n                {this.state.editingPerson === true && sideDrawer}\r\n                <div className=\"zoom_wrapper\">\r\n                    <button onClick={this.zoom.bind(this, 1)} disabled={this.state.zoomLvl == this.#zoomMax}>+</button>\r\n                    <button onClick={this.zoom.bind(this, -1)} disabled={this.state.zoomLvl == this.#zoomMin}>-</button>\r\n                </div>\r\n                <div id=\"family_tree\" className=\"family_tree\" onMouseMove={this.state.isDragging ? (e) => this.tryDrag(e, document.getElementById(\"family_tree\")) : undefined}>\r\n                    {familyMembers}\r\n                    <ConnectionRenderer style={this.calcCssSizeOfConnectionRenderer()}>\r\n                        {connections}\r\n                    </ConnectionRenderer>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default FamilyView;","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js",["118","119","120"],"import Person from './Person';\r\n\r\nclass FamilyTree\r\n{\r\n    static minFamilyMemberLocation = {x: 1, y: 1};\r\n\r\n    treeName;\r\n    creationDate;\r\n    family = []; //array of instances of Person class\r\n\r\n    constructor(treeName, creationDate, family)\r\n    {\r\n        this.treeName = treeName;\r\n        this.creationDate = creationDate;\r\n        this.family = family;\r\n    }\r\n\r\n    static makeNewName(takenNames)\r\n    {\r\n        let newName = \"My Tree 1\";\r\n        let i = 1;\r\n        while (takenNames.includes(newName))\r\n        {\r\n            i++;\r\n            newName = \"My Tree \" + i;\r\n        }\r\n        return newName;\r\n    }\r\n\r\n    static isFamilyMemberLocationBelowMin(location)\r\n    {\r\n        return (location.x < this.minFamilyMemberLocation.x || location.y < this.minFamilyMemberLocation.y);\r\n    }\r\n\r\n    static getShiftVector(location)\r\n    {\r\n        const x = (location.x < this.minFamilyMemberLocation.x) ? this.minFamilyMemberLocation.x - location.x : 0;\r\n        const y = (location.y < this.minFamilyMemberLocation.y) ? this.minFamilyMemberLocation.y - location.y : 0;\r\n        return {x: x, y: y};\r\n    }\r\n\r\n    static shiftFamily(family, vector)\r\n    {\r\n        for(let i = 0; i < family.length; i++)\r\n        {\r\n            family[i].locationInTreeX += vector.x;\r\n            family[i].locationInTreeY += vector.y;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shifts location of all members of a provided family by a vector.\r\n     * This returns a new array and also its contents are clones, to provide immutability for react.\r\n     */\r\n    static shiftFamilyImmutably(family, vector)\r\n    {\r\n        const newFam = [];\r\n        let draft;\r\n        for(let i = 0; i < family.length; i++)\r\n        {\r\n            draft = Person.cloneFromOther(family[i]);\r\n            draft.locationInTreeX += vector.x;\r\n            draft.locationInTreeY += vector.y;\r\n            newFam.push(draft);\r\n        }\r\n        return newFam;\r\n    }\r\n\r\n    fillDataFromJSON(unparsedJson)\r\n    {\r\n        this.fillDataFromParsedJSON(JSON.parse(unparsedJson));\r\n    }\r\n\r\n    fillDataFromParsedJSON(parsedJsonObj)\r\n    {\r\n        //used for loading family trees from JSON files\r\n        //the way you would use it is you first create an instance of FamilyTree,\r\n        //then you call this to fill in data, where parsedJsonObj is something JSON.parse() returns\r\n        //this is done (instead of only using the constructor) to preserve instance functions,\r\n        //since JSON.stringify() drops them\r\n        this.treeName = parsedJsonObj.treeName;\r\n        this.creationDate = parsedJsonObj.creationDate;\r\n        this.family.length = 0;\r\n        for(let i = 0; i < parsedJsonObj.family.length; i++)\r\n        {\r\n            const personObj = new Person(parsedJsonObj.family[i].id);\r\n            personObj.fillDataFromParsedJSON(parsedJsonObj.family[i]);\r\n            this.family.push(personObj);\r\n        }\r\n    }\r\n\r\n    fillDataFromOther(otherTree)\r\n    {\r\n        this.treeName = otherTree.treeName;\r\n        this.creationDate = otherTree.creationDate;\r\n        this.family = otherTree.family;\r\n    }\r\n\r\n    findLowestUnusedFamilyMemberId()\r\n    {\r\n        let newId = -1;\r\n        let idExists = true;\r\n        while (idExists)\r\n        {\r\n            newId++;\r\n            idExists = false;\r\n            for(let i = 0; i < this.family.length; i++)\r\n            {\r\n                if (newId == this.family[i].id) {idExists = true;}\r\n            }\r\n        }\r\n        return newId;\r\n    }\r\n\r\n    static cloneFromOther(otherTree)\r\n    {\r\n        return new FamilyTree(otherTree.treeName, otherTree.creationDate, [...otherTree.family]);\r\n    }\r\n\r\n    save()\r\n    {\r\n        localStorage.setItem(this.treeName, JSON.stringify(this));\r\n    }\r\n\r\n    findFreeLocationUpwards(idOfRefPerson, marginX, marginY)\r\n    {\r\n        //upwards dir is -1 since coords are counted from top\r\n        return this.findFreeLocationVertically(idOfRefPerson, marginX, marginY, -1, true, marginX + 1);\r\n    }\r\n\r\n    findFreeLocationDownwards(idOfRefPerson, marginX, marginY)\r\n    {\r\n        return this.findFreeLocationVertically(idOfRefPerson, marginX, marginY, 1, true, marginX + 1);\r\n    }\r\n\r\n    findFreeLocationVertically(idOfRefPerson, marginX, marginY, dir, checkPerifery, periferyRange)\r\n    {\r\n        const i = this.family.findIndex(item => item.id == idOfRefPerson);\r\n        if (i < 0) {return null;}\r\n        const refPerson =  this.family[i];\r\n        const searchRangeY = 100 + marginY;\r\n        for(let i = marginY + 1; i < searchRangeY; i++)\r\n        {\r\n            const y = (dir > 0) ? refPerson.locationInTreeY + i : refPerson.locationInTreeY - i;\r\n            if (this.isLocationFree(refPerson.locationInTreeX, y, marginX, marginY))\r\n            {\r\n                return {x: refPerson.locationInTreeX, y: y};\r\n            }\r\n            //now check perifery a bit to left and right\r\n            if (checkPerifery)\r\n            {\r\n                if (this.isLocationFree(refPerson.locationInTreeX - periferyRange, y, marginX, marginY))\r\n                {\r\n                    return {x: refPerson.locationInTreeX - periferyRange, y: y};\r\n                }\r\n                if (this.isLocationFree(refPerson.locationInTreeX + periferyRange, y, marginX, marginY))\r\n                {\r\n                    return {x: refPerson.locationInTreeX + periferyRange, y: y};\r\n                }\r\n            }\r\n        }\r\n        return {x: 0, y: 0}; //fallback\r\n    }\r\n\r\n    findFreeLocationNearby(idOfRefPerson, marginX, marginY, rangeX, rangeY)\r\n    {\r\n        //searches first to the sides, then moves up or down, first favouring down\r\n        const i = this.family.findIndex(item => item.id == idOfRefPerson);\r\n        if (i < 0) {return null;}\r\n        const refPerson =  this.family[i];\r\n        const searchRangeX = rangeX + marginX;\r\n        const searchRangeY = rangeY + marginY;\r\n        let x;\r\n        //to the sides:\r\n        for(let i = marginX + 1; i < searchRangeX; i++)\r\n        {\r\n            x = refPerson.locationInTreeX - i;\r\n            if (this.isLocationFree(x, refPerson.locationInTreeY, marginX, marginY))\r\n            {\r\n                return {x: x, y: refPerson.locationInTreeY};\r\n            }\r\n            x = refPerson.locationInTreeX + i;\r\n            if (this.isLocationFree(x, refPerson.locationInTreeY, marginX, marginY))\r\n            {\r\n                return {x: x, y: refPerson.locationInTreeY};\r\n            }\r\n        }\r\n        //up and down alternating, with down first, to the sides, proioritizing left\r\n        let y;\r\n        for(let i = marginY + 1; i < searchRangeY; i++)\r\n        {\r\n            for(let q = marginX + 1; q < searchRangeX; q++)\r\n            {\r\n                y = refPerson.locationInTreeY + i;\r\n                x = refPerson.locationInTreeX - q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                x = refPerson.locationInTreeX + q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                y = refPerson.locationInTreeY - i;\r\n                x = refPerson.locationInTreeX - q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                x = refPerson.locationInTreeX + q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n            }\r\n        }\r\n        return {x: 0, y: 0}; //fallback\r\n    }\r\n\r\n    isLocationFree(x, y, marginX, marginY)\r\n    {\r\n        const minX = x - marginX;\r\n        const minY = y - marginY;\r\n        const maxX = x + marginX;\r\n        const maxY = y + marginY;\r\n        for(let i = 0; i < this.family.length; i++)\r\n        {\r\n            if (this.family[i].locationInTreeX >= minX && this.family[i].locationInTreeX <= maxX && this.family[i].locationInTreeY >= minY && this.family[i].locationInTreeY <= maxY)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get maximal locations of family members in this tree, both in x and y axis. Can be stretched by overhead.\r\n     */\r\n    getBounds(overheadX = 0, overheadY = 0)\r\n    {\r\n        const bounds = {x: 0, y: 0};\r\n        for(let i = 0; i < this.family.length; i++)\r\n        {\r\n            if (this.family[i].locationInTreeX > bounds.x) {bounds.x = this.family[i].locationInTreeX;}\r\n            if (this.family[i].locationInTreeY > bounds.y) {bounds.y = this.family[i].locationInTreeY;}\r\n        }\r\n        bounds.x += overheadX;\r\n        bounds.y += overheadY;\r\n        return bounds;\r\n    }\r\n}\r\n\r\nexport default FamilyTree;","D:\\ReactProjects\\lite-lineage\\src\\Person.js",["121","122","123","124","125","126","127","128"],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx",["129","130"],"import React, { Component } from 'react';\r\nimport '../App.css';\r\nimport Person from '../Person';\r\nimport SelectParent from './SelectParent';\r\nimport SpecialDateInput from './SpecialDateInput';\r\n\r\nclass EditMemberForm extends Component\r\n{\r\n    #noneSign = \"-\";\r\n\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        //this.state = {}\r\n        this.changeName = this.changeName.bind(this);\r\n        this.changeStr = this.changeStr.bind(this);\r\n        this.changeBool = this.changeBool.bind(this);\r\n        this.changeNotes = this.changeNotes.bind(this);\r\n        this.changeDate = this.changeDate.bind(this);\r\n        this.changeNumberOfHealthProblems = this.changeNumberOfHealthProblems.bind(this);\r\n        this.changeHealthProblem = this.changeHealthProblem.bind(this);\r\n        this.changeParents = this.changeParents.bind(this);\r\n    }\r\n\r\n    //there's a bunch of similar methods, because might need different processing for different types later\r\n    changeName(e, propertyName)\r\n    {\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        const possibleVariants = [\"firstName\", \"lastName\", \"secondName\"];\r\n        if (possibleVariants.includes(propertyName) && draftPerson.hasOwnProperty(propertyName))\r\n        {\r\n            draftPerson[propertyName] = e.target.value;\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n        else\r\n        {\r\n            console.error(\"propertyName:\" + propertyName + \" not recognized as a possible variant, or is not an own property of a Person obj\");\r\n        }\r\n    }\r\n\r\n    changeNotes(e)\r\n    {\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        draftPerson.notes = e.target.value;\r\n        this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n    }\r\n\r\n    changeStr(e, propertyName)\r\n    {\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        if (draftPerson.hasOwnProperty(propertyName))\r\n        {\r\n            draftPerson[propertyName] = e.target.value.toString();\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n        else\r\n        {\r\n            console.error(\"propertyName:\" + propertyName + \" is not an own property of a Person obj\");\r\n        }\r\n    }\r\n\r\n    changeBool(e, propertyName)\r\n    {\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        if (draftPerson.hasOwnProperty(propertyName))\r\n        {\r\n            draftPerson[propertyName] = e.target.checked;\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n        else\r\n        {\r\n            console.error(\"propertyName:\" + propertyName + \" is not an own property of a Person obj\");\r\n        }\r\n    }\r\n\r\n    changeDate(dateObj, propertyName)\r\n    {\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        const possibleVariants = [\"dateBirth\", \"dateDeath\"];\r\n        if (possibleVariants.includes(propertyName) && draftPerson.hasOwnProperty(propertyName))\r\n        {\r\n            draftPerson[propertyName] = dateObj;\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n        else\r\n        {\r\n            console.error(\"propertyName:\" + propertyName + \" not recognized as a possible variant, or is not an own property of a Person obj\");\r\n        }\r\n    }\r\n\r\n    changeParents(e, parentIndex)\r\n    {\r\n        const newParentId = e.target.value;\r\n        if (parentIndex == 0 || parentIndex == 1)\r\n        {\r\n            const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n            draftPerson[\"parentId\" + parentIndex] = (newParentId === this.#noneSign) ? null : newParentId;\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n        else\r\n        {\r\n            console.error(\"invalid parentIndex, should be 0 or 1: \" + parentIndex);\r\n        }\r\n    }\r\n\r\n    changeHealthProblem(e)\r\n    {\r\n        const index = e.target.name.replace(\"health_problem_\", \"\");\r\n        console.log(e);\r\n        if (this.props.editedPerson.healthProblems.length > index && index >= 0)\r\n        {\r\n            const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n            draftPerson.healthProblems[index] = e.target.value;\r\n            this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n        }\r\n    }\r\n\r\n    changeNumberOfHealthProblems(n)\r\n    {\r\n        if (n === 0){return;}\r\n        if (n === -1 && this.props.editedPerson.healthProblems.length < 1){return;}\r\n\r\n        const draftPerson = Person.cloneFromOther(this.props.editedPerson);\r\n        if (n > 0)\r\n        {\r\n            draftPerson.healthProblems.push({text:\"\", id: draftPerson.getUnusedHealthProblemId()});\r\n        }\r\n        else\r\n        {\r\n            draftPerson.healthProblems.splice(-1, 1);\r\n        }\r\n        this.props.handleEdit(this.props.editedPerson.id, draftPerson);\r\n    }\r\n\r\n    component\r\n\r\n    render()\r\n    {\r\n        const healthProblemInputs = this.props.editedPerson.healthProblems.map((problem) => (\r\n            <div className=\"side_drawer_row\">\r\n                <input value={problem.text} onChange={this.changeHealthProblem.bind(this)} type=\"text\" key={problem.id} name={\"health_problem_\" + problem.id} className=\"word_input side_drawer_input\"/>\r\n            </div>\r\n        ));\r\n\r\n        const potentialParents0 = this.props.editedPerson.getValidPotentialParents(this.props.family, true, false);\r\n        const potentialParents1 = this.props.editedPerson.getValidPotentialParents(this.props.family, false, true);\r\n        const currentParents = this.props.editedPerson.getCurrentParents(this.props.family);\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"side_drawer_content_section\">\r\n                    <div className=\"side_drawer_row\">\r\n                        <label htmlFor=\"name_first\" className=\"word_input_label\">First name:</label>\r\n                        <input value={this.props.editedPerson.firstName} onChange={(e) => this.changeName(e, \"firstName\")} type=\"text\" name=\"name_first\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                        <label htmlFor=\"name_second\" className=\"word_input_label\">Second name:</label>\r\n                        <input value={this.props.editedPerson.secondName} onChange={(e) => this.changeName(e, \"secondName\")} type=\"text\" name=\"name_second\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                        <label htmlFor=\"name_last\" className=\"word_input_label\">Last name:</label>\r\n                        <input value={this.props.editedPerson.lastName} onChange={(e) => this.changeName(e, \"lastName\")} type=\"text\" name=\"name_last\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                        <label htmlFor=\"is_dead\" className=\"checkbox_input_label\">Deceased:</label>\r\n                        <input checked={this.props.editedPerson.isDead} onChange={(e) => this.changeBool(e, \"isDead\")} type=\"checkbox\" name=\"is_dead\" className=\"checkbox_input side_drawer_input\"/>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"side_drawer_content_section\">\r\n                    <div className=\"side_drawer_row\">Parents:\r\n                        <SelectParent handleChange={this.changeParents} currentParent={currentParents[0]} potentialParents={potentialParents0} parentSlotIndex={0} noneSign={this.#noneSign}/>\r\n                        <SelectParent handleChange={this.changeParents} currentParent={currentParents[1]} potentialParents={potentialParents1} parentSlotIndex={1} noneSign={this.#noneSign}/>\r\n                    </div>\r\n                </div>\r\n\r\n                <SpecialDateInput\r\n                    date={this.props.editedPerson.dateBirth}\r\n                    useFull={this.props.editedPerson.useFullDateBirth}\r\n                    impreciseYear={this.props.editedPerson.unsurePreciseYearOfBirth}\r\n                    unknownDate={this.props.editedPerson.unknownDateOfBirth}\r\n                    dateOfStr={\"birth\"}\r\n                    displayedDate={this.props.editedPerson.getDisplayDateBirth()}\r\n                    handleChangeDate={this.changeDate}\r\n                    handleChangeBool={this.changeBool}\r\n                    propertySuffix={\"Birth\"}\r\n                    disabled={false}\r\n                />\r\n\r\n                <SpecialDateInput\r\n                    date={this.props.editedPerson.dateDeath}\r\n                    useFull={this.props.editedPerson.useFullDateDeath}\r\n                    unsurePreciseYear={this.props.editedPerson.unsurePreciseYearOfDeath}\r\n                    unknownDate={this.props.editedPerson.unknownDateOfDeath}\r\n                    dateOfStr={\"death\"}\r\n                    displayedDate={this.props.editedPerson.getDisplayDateDeath()}\r\n                    handleChangeDate={this.changeDate}\r\n                    handleChangeBool={this.changeBool}\r\n                    propertySuffix={\"Death\"}\r\n                    disabled={!this.props.editedPerson.isDead}\r\n                />\r\n\r\n                <div className=\"side_drawer_content_section\">\r\n                    <div className=\"side_drawer_row\">\r\n                    <label htmlFor=\"cause_of_death\" className=\"word_input_label\">Cause of death:</label>\r\n                    <input disabled={!this.props.editedPerson.isDead} value={this.props.editedPerson.causeOfDeath} onChange={(e) => this.changeStr(e, \"causeOfDeath\")} type=\"text\" name=\"cause_of_death\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                    <label htmlFor=\"place_birth\" className=\"word_input_label\">Place of birth:</label>\r\n                    <input value={this.props.editedPerson.placeBirth} onChange={(e) => this.changeStr(e, \"placeBirth\")} type=\"text\" name=\"place_birth\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                    <label htmlFor=\"place_death\" className=\"word_input_label\">Place of death:</label>\r\n                    <input disabled={!this.props.editedPerson.isDead} value={this.props.editedPerson.placeDeath} onChange={(e) => this.changeStr(e, \"placeDeath\")} type=\"text\" name=\"place_death\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n                </div>\r\n                \r\n                <div className=\"side_drawer_content_section\">\r\n                    <div className=\"side_drawer_row\">\r\n                    <label htmlFor=\"color_eye\" className=\"word_input_label\">Eye color:</label>\r\n                    <input value={this.props.editedPerson.colorEyes} onChange={(e) => this.changeStr(e, \"colorEyes\")} type=\"text\" name=\"color_eye\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n\r\n                    <div className=\"side_drawer_row\">\r\n                    <label htmlFor=\"color_hair\" className=\"word_input_label\">Hair color:</label>\r\n                    <input value={this.props.editedPerson.colorHair} onChange={(e) => this.changeStr(e, \"colorHair\")} type=\"text\" name=\"color_hair\" className=\"word_input side_drawer_input\"/>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"side_drawer_content_section\">\r\n                    <div className=\"side_drawer_input_list\">\r\n                        <p className=\"side_drawer_row\">Diseases and health problems:</p>\r\n                        {healthProblemInputs}\r\n                        <div className=\"side_drawer_row\">\r\n                            <button type=\"button\" onClick={this.changeNumberOfHealthProblems.bind(this, 1)}>+</button>\r\n                            <button type=\"button\" onClick={this.changeNumberOfHealthProblems.bind(this, -1)}>-</button>\r\n                        </div>\r\n                    </div>\r\n\r\n                    <label htmlFor=\"notes\" className=\"side_drawer_row\">Notes:</label>\r\n                    <textarea value={this.props.editedPerson.notes} onChange={this.changeNotes} name=\"notes\" className=\"multiline_input side_drawer_input\"/> \r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default EditMemberForm;","D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\Helpers.js",["131","132","133"],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js",["134","135"],"/**Class for representing 2 dimensional vectors, useful both for points and for vectors representing translation/movement/direction.*/\r\nclass V2\r\n{\r\n    constructor(x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.dims = [x, y];\r\n\r\n        //binding this for all methods that are non-static\r\n        for(let property in this)\r\n        {\r\n            if (this.hasOwnProperty(property) && typeof this[property] == \"function\")\r\n            {\r\n                this[property] = this[property].bind(this);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**Returns true when this vector is equal to other. Tolerance is used for V2s with floating point values for dimensions.\r\n     * For vectors inteded for integers, keep the tolerance = 0, as it is by default. If vectors are floats, values between 0.001 and 0.00001 are recommended.\r\n     */\r\n    equal(other, tolerance = 0)\r\n    {\r\n        const absDiff = this.diff(other).abs();\r\n        return (absDiff.x <= tolerance && absDiff.y <= tolerance);\r\n    }\r\n\r\n    /**Returns a new V2 that is the result of making both dimensions of this vector absolute.*/\r\n    abs()\r\n    {\r\n        return new V2(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    /**Adds v2 to this vector, returning a new instance of V2. */\r\n    add(v2)\r\n    {\r\n        return new V2(this.x + v2.x, this.y + v2.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is the sum of all passed vectors. */\r\n    static sum(...vectors)\r\n    {\r\n        const result = new V2(0, 0);\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            result.add(vectors[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**Subtracts v2 from this vector, returning a new V2. */\r\n    sub(v2)\r\n    {\r\n        return new V2(this.x - v2.x, this.y - v2.y);\r\n    }\r\n\r\n\r\n    /**Returns a result of a - b. */\r\n    static diff(a, b)\r\n    {\r\n        return a.sub(b);\r\n    }\r\n\r\n    /**Multiplies this vector by a number and returns a new V2. */\r\n    mult(multiplier)\r\n    {\r\n        return new V2(this.x * multiplier, this.y * multiplier);\r\n    }\r\n\r\n    /**Divides this vector by a number and returns a new V2. */\r\n    divide(divider)\r\n    {\r\n        if (divider == 0) {return new V2(NaN, NaN);}\r\n        return new V2(this.x / divider, this.y / divider);\r\n    }\r\n\r\n    //shorthands\r\n    /**Shorthand for writing new V2(0, 0) */\r\n    static get zero() {return new V2(0, 0);}\r\n    /**Shorthand for writing new V2(0, 0) */\r\n    static get one() {return new V2(1, 1);}\r\n    /**A vector pointing up. Shorthand for writing new V2(1, 1) */\r\n    static get u() {return new V2(0, 1);}\r\n    /**A vector pointing down. Shorthand for writing new V2(0, 1) */\r\n    static get d() {return new V2(0, -1);}\r\n    /**A vector pointing left. Shorthand for writing new V2(-1, 0) */\r\n    static get l() {return new V2(-1, 0);}\r\n    /**A vector pointing right. Shorthand for writing new V2(1, 0) */\r\n    static get r() {return new V2(1, 0);}\r\n\r\n    //clockwise array of basic directions\r\n    static get adjDirs() {return [V2.u, V2.r, V2.d, V2.l];}\r\n    static get diagDirs() {return [new V2(1, 1), new V2(1, -1), new V2(-1, -1), new V2(-1, 1)];}\r\n    static get baseDirs()\r\n    {\r\n        return[\r\n            V2.u,\r\n            new V2(1, 1),\r\n            V2.r,\r\n            new V2(1, -1),\r\n            V2.d,\r\n            new V2(-1, -1),\r\n            V2.l,\r\n            new V2(-1, 1),\r\n        ];\r\n    }\r\n\r\n    /**Returns a new V2 that is a clone of this one. */\r\n    clone()\r\n    {\r\n        return new V2(this.x, this.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is a clone of other. */\r\n    static cloneFrom(other)\r\n    {\r\n        return new V2(other.x, other.y);\r\n    }\r\n\r\n    /**Returns the squared euclidian distance between points a and b. */\r\n    static sqDist(a, b)\r\n    {\r\n        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\r\n    }\r\n\r\n    /**Returns the euclidian distance between point a and b.*/\r\n    static dist(a, b)\r\n    {\r\n        return Math.sqrt(V2.sqDist(a, b));\r\n    }\r\n\r\n    /**Returns the Manhattan distance between points a and b. */\r\n    static mhDist(a, b)\r\n    {\r\n        const v = b.sub(a);\r\n        return Math.abs(v.x) + Math.abs(v.y);\r\n    }\r\n\r\n    /**Returns the magnitude (also called length) of this vector.*/\r\n    magnitude()\r\n    {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    /**Returns normalized instance of this V2, which means it makes it have magnitude = 1, preserving the direction. Returns V2.zero() when current magnitude is 0.*/\r\n    normalize()\r\n    {\r\n        const mag = this.magnitude();\r\n        if (mag === 0){console.log(\"Tried normalizing vector with 0 magnitude.\"); return V2.zero;}\r\n        return new V2(this.x / mag, this.y / mag);\r\n    }\r\n\r\n    /**Returns the dot product of a and b.*/\r\n    static dot(a, b)\r\n    {\r\n        return a.x * b.x + a.y * b.y;\r\n    }\r\n\r\n    /**Returns the dot product of a and b after normalizing both of them.*/\r\n    static normDot(a, b)\r\n    {\r\n        const nA = a.normalize();\r\n        const nB = b.normalize();\r\n        return V2.dot(nA, nB);\r\n    }\r\n  \r\n    /**Returns the signed angle of this vector in degrees in relation to the x axis. This means V2.right() will return 0 degrees.\r\n     * V2.up() will return -90, V2.down() 90, etc. The range of return values is between -180 and 180.\r\n     */\r\n    angleRaw()\r\n    {\r\n        return Math.atan2(this.y, this.x) * 180 / Math.PI;\r\n    }\r\n\r\n    /**Returns the unsigned angle of this vector in degrees, from 0 to 360, starting at V2.up() and going clockwise. */\r\n    angle()\r\n    {\r\n        const angle = this.angleRaw();\r\n        return (angle >= -90 && angle <= 180) ? angle + 90 : angle + 450;\r\n    }\r\n\r\n    /**Returns the unsigned angle between 2 vectors a and b. The range of return values is between 0 and 180 */\r\n    static angleBetween(a, b)\r\n    {\r\n        return Math.abs(Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x) * 180 / Math.PI);\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded from this vector. */\r\n    round()\r\n    {\r\n        return new V2(Math.round(this.x), Math.round(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded up from this vector. */\r\n    ceil()\r\n    {\r\n        return new V2(Math.ceil(this.x), Math.ceil(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded down from this vector. */\r\n    floor()\r\n    {\r\n        return new V2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 of which y is the x of this one, and of which x is the y of this one */\r\n    swapDimensions()\r\n    {\r\n        return new V2(this.y, this.x);\r\n    }\r\n\r\n    /**Scales this vector to a set magnitude, returning a new instance of V2. Might be prone to floating point innacuracies. */\r\n    setMagnitude(target)\r\n    {\r\n        if (target < 0) {console.error(\"Trying to set magnitude to a negative value, this is not possible.\"); return V2.zero();}\r\n        const normalized = this.normalize();\r\n        return normalized.mult(target);\r\n    }\r\n\r\n    /**If the magnitude of this vector exceeds min and max, forces it to be within range. Returns a new V2. */\r\n    clampMagnitude(min, max)\r\n    {\r\n        if (min < 0){min = 0;}\r\n        const mag = this.magnitude();\r\n        if (mag < min) {return this.setMagnitude(min);}\r\n        if (mag > max) {return this.setMagnitude(max);}\r\n        return this;\r\n    }\r\n\r\n    /**Returns a new V2 that is the result of multiplying this vector and another component-wise. */\r\n    scale(v2)\r\n    {\r\n        return new V2(this.x * v2.x, this.y * v2.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is made up of the smallest x and the smallest y found within passed vectors. Returns null if none passed.*/\r\n    static min(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        let minX, minY = Number.POSITIVE_INFINITY;\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            if (vectors[i].x < minX) {minX = vectors[i].x;}\r\n            if (vectors[i].y < minY) {minY = vectors[i].y;}\r\n        }\r\n        return new V2(minX, minY);\r\n    }\r\n\r\n    /**Returns a new V2 that is made up of the biggest x and the biggest y found within passed vectors. Returns null if none passed.*/\r\n    static max(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        let maxX, maxY = Number.NEGATIVE_INFINITY;\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            if (vectors[i].x > maxX) {maxX = vectors[i].x;}\r\n            if (vectors[i].y > maxY) {maxY = vectors[i].y;}\r\n        }\r\n        return new V2(maxX, maxY);\r\n    }\r\n\r\n    /**Returns a new V2 representing the ranges between minimal and maximal values of x and of y occuring within passed vectors. Returns null if none passed.*/\r\n    static rangeDimensionally(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        const min = V2.min(...vectors);\r\n        const max = V2.max(...vectors);\r\n        return new V2(max.x - min.x, max.y - min.y);\r\n    }\r\n\r\n    /**Returns a point that is a frac fraction of the way between points a and b, eg. if the fraction is 0.5, returns the halfway point.*/\r\n    static getPointBetween(a, b, frac = 0.5)\r\n    {\r\n        const dir = b.sub(a);\r\n        return a.add(dir.mult(frac));\r\n    }\r\n\r\n    /**Returns an array of n points spaced equally between points a and b. Eg. if n = 3, points are 1/4 of the way, 1/2 of the way and 3/4 of the way.\r\n     * If includeEnds is true, the array also includes point a at [0], and point b at [last], in that case the length of the return array is n + 2.\r\n     */\r\n    static getPointsBetween(a, b, n, includeEnds)\r\n    {\r\n        const returnArray = [];\r\n        if (includeEnds) {returnArray.push(V2.cloneFrom(a));}\r\n        const fracBase = 1 / (1 + Math.abs(n));\r\n        let frac;\r\n        for(let i = 0; i < n; i++)\r\n        {\r\n            frac = fracBase * (i + 1);\r\n            returnArray.push(V2.getPointBetween(a, b, frac));\r\n        }\r\n        if (includeEnds) {returnArray.push(V2.cloneFrom(b));}\r\n        return returnArray;\r\n    }\r\n\r\n    /**Returns true if this vector is perpendicular to other (angled at 90 degrees). Tolerance is used to determine how precisely the 2 vectors need to be perpendicular for it to be considered true.\r\n     * A value of 0 means only exactly perpendicular vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended.*/\r\n    isPerpendicular(other, tolerance = 0.0001)\r\n    {\r\n        return (Math.abs(V2.normDot(this, other)) <= tolerance);\r\n    }\r\n\r\n    /**Returns true if this vector is paralell to other. Tolerance is used to determine how precisely the 2 vectors need to be paralell for it to be considered true.\r\n     * A value of 0 means only exactly paralell vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended.\r\n    */\r\n    isParallel(other, tolerance = 0.0001)\r\n    {\r\n        return (Math.abs(V2.normDot(this, other) - 1) <= tolerance) || (Math.abs(V2.normDot(this, other) + 1) <= tolerance);\r\n    }\r\n\r\n    /**Returns true if all the vectors passed in are parallel. Tolerance is used to determine how precisely the 2 vectors need to be paralell for it to be considered true.\r\n     * A value of 0 means only exactly paralell vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended. If there's no vectors for comparison returns true.\r\n     */\r\n    static areParallel(tolerance = 0.0001, ...vectors)\r\n    {\r\n        if (!vectors || vectors.length < 2){return true;}\r\n        for(let i = 1; i < vectors.length; i++)\r\n        {\r\n            if (!vectors[i - 1].isParallel(vectors[i], tolerance))\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**Returns a new V2 perpendicular to this one. Y axis is always positive and the magnitude is preserved.*/ \r\n    getPerpendicular()\r\n    {\r\n        return (this.x >= 0) ? new V2(-this.y, this.x) : new V2(this.y, -this.x);\r\n    }\r\n\r\n    /**Returns an array of integer points adjacent to this point. Adjacent means north, south, east, west.*/\r\n    getAdj()\r\n    {\r\n        const rounded = this.round();\r\n        return [rounded.add(V2.u), rounded.add(V2.r), rounded.add(V2.d), rounded.add(V2.l)];\r\n    }\r\n\r\n    /**Returns an array of integer points diagonal to this point.*/\r\n    getDiag()\r\n    {\r\n        const rounded = this.round();\r\n        return [rounded.add(new V2(1, 1)), rounded.add(new V2(1, -1)), rounded.add(new V2(-1, -1)), rounded.add(new V2(-1, 1))];\r\n    }\r\n\r\n    /**Returns an array of integer points adjacent and diagonal to this point. */\r\n    getSurrounding()\r\n    {\r\n        const rounded = this.round();\r\n        return [\r\n            rounded.add(V2.u),\r\n            rounded.add(new V2(1, 1)),\r\n            rounded.add(V2.r),\r\n            rounded.add(new V2(1, -1)),\r\n            rounded.add(V2.d),\r\n            rounded.add(new V2(-1, -1)),\r\n            rounded.add(V2.l),\r\n            rounded.add(new V2(-1, 1)),\r\n        ];\r\n    }\r\n\r\n    /**Returns true if this integer point is adjacent to to. Adjacent means north, south, east, west. */\r\n    isAdj(to)\r\n    {\r\n        for(let i = 0; i < V2.adjDirs.length; i++)\r\n        {\r\n            if (this.add(V2.adjDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns true if this integer point is diagonal to to.*/\r\n    isDiag(to)\r\n    {\r\n        for(let i = 0; i < V2.diagDirs.length; i++)\r\n        {\r\n            if (this.add(V2.diagDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns true if this integer point is diagonal or adjacent to to.*/\r\n    isSurr(to)\r\n    {\r\n        for(let i = 0; i < V2.baseDirs.length; i++)\r\n        {\r\n            if (this.add(V2.baseDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns a string representation of this vector that looks like this: [x; y] */\r\n    toString()\r\n    {\r\n        return \"[\" + this.x.toString() + \"; \" + this.y.toString() + \"]\";\r\n    }\r\n}\r\n\r\nexport default V2",["136","137"],"D:\\ReactProjects\\lite-lineage\\src\\components\\Notice.jsx",[],{"ruleId":"138","replacedBy":"139"},{"ruleId":"140","replacedBy":"141"},{"ruleId":"142","severity":1,"message":"143","line":228,"column":87,"nodeType":"144","messageId":"145","endLine":228,"endColumn":89},{"ruleId":"142","severity":1,"message":"143","line":281,"column":51,"nodeType":"144","messageId":"145","endLine":281,"endColumn":53},{"ruleId":"142","severity":1,"message":"146","line":306,"column":26,"nodeType":"144","messageId":"145","endLine":306,"endColumn":28},{"ruleId":"142","severity":1,"message":"143","line":311,"column":57,"nodeType":"144","messageId":"145","endLine":311,"endColumn":59},{"ruleId":"142","severity":1,"message":"143","line":330,"column":51,"nodeType":"144","messageId":"145","endLine":330,"endColumn":53},{"ruleId":"142","severity":1,"message":"143","line":55,"column":96,"nodeType":"144","messageId":"145","endLine":55,"endColumn":98},{"ruleId":"142","severity":1,"message":"143","line":90,"column":81,"nodeType":"144","messageId":"145","endLine":90,"endColumn":83},{"ruleId":"142","severity":1,"message":"143","line":126,"column":17,"nodeType":"144","messageId":"145","endLine":126,"endColumn":19},{"ruleId":"142","severity":1,"message":"143","line":197,"column":93,"nodeType":"144","messageId":"145","endLine":197,"endColumn":95},{"ruleId":"142","severity":1,"message":"143","line":218,"column":92,"nodeType":"144","messageId":"145","endLine":218,"endColumn":94},{"ruleId":"142","severity":1,"message":"143","line":219,"column":93,"nodeType":"144","messageId":"145","endLine":219,"endColumn":95},{"ruleId":"142","severity":1,"message":"143","line":109,"column":27,"nodeType":"144","messageId":"145","endLine":109,"endColumn":29},{"ruleId":"142","severity":1,"message":"143","line":138,"column":57,"nodeType":"144","messageId":"145","endLine":138,"endColumn":59},{"ruleId":"142","severity":1,"message":"143","line":168,"column":57,"nodeType":"144","messageId":"145","endLine":168,"endColumn":59},{"ruleId":"142","severity":1,"message":"143","line":123,"column":25,"nodeType":"144","messageId":"145","endLine":123,"endColumn":27},{"ruleId":"142","severity":1,"message":"143","line":123,"column":64,"nodeType":"144","messageId":"145","endLine":123,"endColumn":66},{"ruleId":"142","severity":1,"message":"143","line":123,"column":98,"nodeType":"144","messageId":"145","endLine":123,"endColumn":100},{"ruleId":"142","severity":1,"message":"143","line":124,"column":30,"nodeType":"144","messageId":"145","endLine":124,"endColumn":32},{"ruleId":"142","severity":1,"message":"143","line":125,"column":30,"nodeType":"144","messageId":"145","endLine":125,"endColumn":32},{"ruleId":"142","severity":1,"message":"143","line":140,"column":53,"nodeType":"144","messageId":"145","endLine":140,"endColumn":55},{"ruleId":"142","severity":1,"message":"143","line":141,"column":53,"nodeType":"144","messageId":"145","endLine":141,"endColumn":55},{"ruleId":"142","severity":1,"message":"143","line":173,"column":47,"nodeType":"144","messageId":"145","endLine":173,"endColumn":49},{"ruleId":"142","severity":1,"message":"143","line":94,"column":25,"nodeType":"144","messageId":"145","endLine":94,"endColumn":27},{"ruleId":"142","severity":1,"message":"143","line":94,"column":45,"nodeType":"144","messageId":"145","endLine":94,"endColumn":47},{"ruleId":"142","severity":1,"message":"143","line":7,"column":37,"nodeType":"144","messageId":"145","endLine":7,"endColumn":39},{"ruleId":"142","severity":1,"message":"146","line":7,"column":59,"nodeType":"144","messageId":"145","endLine":7,"endColumn":61},{"ruleId":"142","severity":1,"message":"143","line":7,"column":82,"nodeType":"144","messageId":"145","endLine":7,"endColumn":84},{"ruleId":"147","severity":1,"message":"148","line":13,"column":22,"nodeType":"149","messageId":"150","endLine":13,"endColumn":36},{"ruleId":"142","severity":1,"message":"143","line":75,"column":21,"nodeType":"144","messageId":"145","endLine":75,"endColumn":23},{"ruleId":"138","replacedBy":"139"},{"ruleId":"140","replacedBy":"141"},"no-native-reassign",["151"],"no-negated-in-lhs",["152"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","no-global-assign","no-unsafe-negation"]