[{"D:\\ReactProjects\\lite-lineage\\src\\index.js":"1","D:\\ReactProjects\\lite-lineage\\src\\App.js":"2","D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js":"3","D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx":"4","D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx":"5","D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx":"6","D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx":"7","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx":"8","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx":"9","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx":"10","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx":"11","D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx":"12","D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js":"13","D:\\ReactProjects\\lite-lineage\\src\\Person.js":"14","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx":"15","D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx":"16","D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js":"17","D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx":"18","D:\\ReactProjects\\lite-lineage\\src\\Helpers.js":"19","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx":"20","D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx":"21","D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx":"22","D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js":"23","D:\\ReactProjects\\lite-lineage\\src\\components\\Notice.jsx":"24"},{"size":500,"mtime":499162500000,"results":"25","hashOfConfig":"26"},{"size":12249,"mtime":1611516924846,"results":"27","hashOfConfig":"26"},{"size":362,"mtime":499162500000,"results":"28","hashOfConfig":"26"},{"size":498,"mtime":1611498369513,"results":"29","hashOfConfig":"26"},{"size":2305,"mtime":1610568177174,"results":"30","hashOfConfig":"26"},{"size":632,"mtime":1611509562555,"results":"31","hashOfConfig":"26"},{"size":3127,"mtime":1611501513125,"results":"32","hashOfConfig":"26"},{"size":9112,"mtime":1611517006301,"results":"33","hashOfConfig":"26"},{"size":3867,"mtime":1611432423577,"results":"34","hashOfConfig":"26"},{"size":612,"mtime":1611498253521,"results":"35","hashOfConfig":"26"},{"size":1139,"mtime":1611498322843,"results":"36","hashOfConfig":"26"},{"size":1397,"mtime":1610649766940,"results":"37","hashOfConfig":"26"},{"size":8607,"mtime":1611517051454,"results":"38","hashOfConfig":"26"},{"size":7124,"mtime":1611516954070,"results":"39","hashOfConfig":"26"},{"size":12496,"mtime":1611517012925,"results":"40","hashOfConfig":"26"},{"size":1850,"mtime":1611498297626,"results":"41","hashOfConfig":"26"},{"size":296,"mtime":1611498484830,"results":"42","hashOfConfig":"26"},{"size":5468,"mtime":1611498272986,"results":"43","hashOfConfig":"26"},{"size":2700,"mtime":1611516998463,"results":"44","hashOfConfig":"26"},{"size":3205,"mtime":1611495263805,"results":"45","hashOfConfig":"26"},{"size":260,"mtime":1611498417865,"results":"46","hashOfConfig":"26"},{"size":1076,"mtime":1611438985631,"results":"47","hashOfConfig":"26"},{"size":14215,"mtime":1611494936093,"results":"48","hashOfConfig":"49"},{"size":762,"mtime":1611509507278,"results":"50","hashOfConfig":"26"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},"19gfp4v",{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"88"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"100"},"16qv85j",{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"53"},"D:\\ReactProjects\\lite-lineage\\src\\index.js",[],["103","104"],"D:\\ReactProjects\\lite-lineage\\src\\App.js",[],"D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js",[],"D:\\ReactProjects\\lite-lineage\\src\\Person.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx",[],["105","106"],"D:\\ReactProjects\\lite-lineage\\src\\Helpers.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js",["107","108"],"/**Class for representing 2 dimensional vectors, useful both for points and for vectors representing translation/movement/direction.*/\r\nclass V2\r\n{\r\n    constructor(x, y)\r\n    {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.dims = [x, y];\r\n\r\n        //binding this for all methods that are non-static\r\n        for(let property in this)\r\n        {\r\n            if (this.hasOwnProperty(property) && typeof this[property] == \"function\")\r\n            {\r\n                this[property] = this[property].bind(this);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**Returns true when this vector is equal to other. Tolerance is used for V2s with floating point values for dimensions.\r\n     * For vectors inteded for integers, keep the tolerance = 0, as it is by default. If vectors are floats, values between 0.001 and 0.00001 are recommended.\r\n     */\r\n    equal(other, tolerance = 0)\r\n    {\r\n        const absDiff = this.diff(other).abs();\r\n        return (absDiff.x <= tolerance && absDiff.y <= tolerance);\r\n    }\r\n\r\n    /**Returns a new V2 that is the result of making both dimensions of this vector absolute.*/\r\n    abs()\r\n    {\r\n        return new V2(Math.abs(this.x), Math.abs(this.y));\r\n    }\r\n\r\n    /**Adds v2 to this vector, returning a new instance of V2. */\r\n    add(v2)\r\n    {\r\n        return new V2(this.x + v2.x, this.y + v2.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is the sum of all passed vectors. */\r\n    static sum(...vectors)\r\n    {\r\n        const result = new V2(0, 0);\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            result.add(vectors[i]);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**Subtracts v2 from this vector, returning a new V2. */\r\n    sub(v2)\r\n    {\r\n        return new V2(this.x - v2.x, this.y - v2.y);\r\n    }\r\n\r\n\r\n    /**Returns a result of a - b. */\r\n    static diff(a, b)\r\n    {\r\n        return a.sub(b);\r\n    }\r\n\r\n    /**Multiplies this vector by a number and returns a new V2. */\r\n    mult(multiplier)\r\n    {\r\n        return new V2(this.x * multiplier, this.y * multiplier);\r\n    }\r\n\r\n    /**Divides this vector by a number and returns a new V2. */\r\n    divide(divider)\r\n    {\r\n        if (divider == 0) {return new V2(NaN, NaN);}\r\n        return new V2(this.x / divider, this.y / divider);\r\n    }\r\n\r\n    //shorthands\r\n    /**Shorthand for writing new V2(0, 0) */\r\n    static get zero() {return new V2(0, 0);}\r\n    /**Shorthand for writing new V2(0, 0) */\r\n    static get one() {return new V2(1, 1);}\r\n    /**A vector pointing up. Shorthand for writing new V2(1, 1) */\r\n    static get u() {return new V2(0, 1);}\r\n    /**A vector pointing down. Shorthand for writing new V2(0, 1) */\r\n    static get d() {return new V2(0, -1);}\r\n    /**A vector pointing left. Shorthand for writing new V2(-1, 0) */\r\n    static get l() {return new V2(-1, 0);}\r\n    /**A vector pointing right. Shorthand for writing new V2(1, 0) */\r\n    static get r() {return new V2(1, 0);}\r\n\r\n    //clockwise array of basic directions\r\n    static get adjDirs() {return [V2.u, V2.r, V2.d, V2.l];}\r\n    static get diagDirs() {return [new V2(1, 1), new V2(1, -1), new V2(-1, -1), new V2(-1, 1)];}\r\n    static get baseDirs()\r\n    {\r\n        return[\r\n            V2.u,\r\n            new V2(1, 1),\r\n            V2.r,\r\n            new V2(1, -1),\r\n            V2.d,\r\n            new V2(-1, -1),\r\n            V2.l,\r\n            new V2(-1, 1),\r\n        ];\r\n    }\r\n\r\n    /**Returns a new V2 that is a clone of this one. */\r\n    clone()\r\n    {\r\n        return new V2(this.x, this.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is a clone of other. */\r\n    static cloneFrom(other)\r\n    {\r\n        return new V2(other.x, other.y);\r\n    }\r\n\r\n    /**Returns the squared euclidian distance between points a and b. */\r\n    static sqDist(a, b)\r\n    {\r\n        return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\r\n    }\r\n\r\n    /**Returns the euclidian distance between point a and b.*/\r\n    static dist(a, b)\r\n    {\r\n        return Math.sqrt(V2.sqDist(a, b));\r\n    }\r\n\r\n    /**Returns the Manhattan distance between points a and b. */\r\n    static mhDist(a, b)\r\n    {\r\n        const v = b.sub(a);\r\n        return Math.abs(v.x) + Math.abs(v.y);\r\n    }\r\n\r\n    /**Returns the magnitude (also called length) of this vector.*/\r\n    magnitude()\r\n    {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n\r\n    /**Returns normalized instance of this V2, which means it makes it have magnitude = 1, preserving the direction. Returns V2.zero() when current magnitude is 0.*/\r\n    normalize()\r\n    {\r\n        const mag = this.magnitude();\r\n        if (mag === 0){console.log(\"Tried normalizing vector with 0 magnitude.\"); return V2.zero;}\r\n        return new V2(this.x / mag, this.y / mag);\r\n    }\r\n\r\n    /**Returns the dot product of a and b.*/\r\n    static dot(a, b)\r\n    {\r\n        return a.x * b.x + a.y * b.y;\r\n    }\r\n\r\n    /**Returns the dot product of a and b after normalizing both of them.*/\r\n    static normDot(a, b)\r\n    {\r\n        const nA = a.normalize();\r\n        const nB = b.normalize();\r\n        return V2.dot(nA, nB);\r\n    }\r\n  \r\n    /**Returns the signed angle of this vector in degrees in relation to the x axis. This means V2.right() will return 0 degrees.\r\n     * V2.up() will return -90, V2.down() 90, etc. The range of return values is between -180 and 180.\r\n     */\r\n    angleRaw()\r\n    {\r\n        return Math.atan2(this.y, this.x) * 180 / Math.PI;\r\n    }\r\n\r\n    /**Returns the unsigned angle of this vector in degrees, from 0 to 360, starting at V2.up() and going clockwise. */\r\n    angle()\r\n    {\r\n        const angle = this.angleRaw();\r\n        return (angle >= -90 && angle <= 180) ? angle + 90 : angle + 450;\r\n    }\r\n\r\n    /**Returns the unsigned angle between 2 vectors a and b. The range of return values is between 0 and 180 */\r\n    static angleBetween(a, b)\r\n    {\r\n        return Math.abs(Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x) * 180 / Math.PI);\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded from this vector. */\r\n    round()\r\n    {\r\n        return new V2(Math.round(this.x), Math.round(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded up from this vector. */\r\n    ceil()\r\n    {\r\n        return new V2(Math.ceil(this.x), Math.ceil(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 with x and y being rounded down from this vector. */\r\n    floor()\r\n    {\r\n        return new V2(Math.floor(this.x), Math.floor(this.y));\r\n    }\r\n\r\n    /**Returns a new V2 of which y is the x of this one, and of which x is the y of this one */\r\n    swapDimensions()\r\n    {\r\n        return new V2(this.y, this.x);\r\n    }\r\n\r\n    /**Scales this vector to a set magnitude, returning a new instance of V2. Might be prone to floating point innacuracies. */\r\n    setMagnitude(target)\r\n    {\r\n        if (target < 0) {console.error(\"Trying to set magnitude to a negative value, this is not possible.\"); return V2.zero();}\r\n        const normalized = this.normalize();\r\n        return normalized.mult(target);\r\n    }\r\n\r\n    /**If the magnitude of this vector exceeds min and max, forces it to be within range. Returns a new V2. */\r\n    clampMagnitude(min, max)\r\n    {\r\n        if (min < 0){min = 0;}\r\n        const mag = this.magnitude();\r\n        if (mag < min) {return this.setMagnitude(min);}\r\n        if (mag > max) {return this.setMagnitude(max);}\r\n        return this;\r\n    }\r\n\r\n    /**Returns a new V2 that is the result of multiplying this vector and another component-wise. */\r\n    scale(v2)\r\n    {\r\n        return new V2(this.x * v2.x, this.y * v2.y);\r\n    }\r\n\r\n    /**Returns a new V2 that is made up of the smallest x and the smallest y found within passed vectors. Returns null if none passed.*/\r\n    static min(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        let minX, minY = Number.POSITIVE_INFINITY;\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            if (vectors[i].x < minX) {minX = vectors[i].x;}\r\n            if (vectors[i].y < minY) {minY = vectors[i].y;}\r\n        }\r\n        return new V2(minX, minY);\r\n    }\r\n\r\n    /**Returns a new V2 that is made up of the biggest x and the biggest y found within passed vectors. Returns null if none passed.*/\r\n    static max(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        let maxX, maxY = Number.NEGATIVE_INFINITY;\r\n        for(let i = 0; i < vectors.length; i++)\r\n        {\r\n            if (vectors[i].x > maxX) {maxX = vectors[i].x;}\r\n            if (vectors[i].y > maxY) {maxY = vectors[i].y;}\r\n        }\r\n        return new V2(maxX, maxY);\r\n    }\r\n\r\n    /**Returns a new V2 representing the ranges between minimal and maximal values of x and of y occuring within passed vectors. Returns null if none passed.*/\r\n    static rangeDimensionally(...vectors)\r\n    {\r\n        if (!vectors || vectors.length <= 0){return null;}\r\n        const min = V2.min(...vectors);\r\n        const max = V2.max(...vectors);\r\n        return new V2(max.x - min.x, max.y - min.y);\r\n    }\r\n\r\n    /**Returns a point that is a frac fraction of the way between points a and b, eg. if the fraction is 0.5, returns the halfway point.*/\r\n    static getPointBetween(a, b, frac = 0.5)\r\n    {\r\n        const dir = b.sub(a);\r\n        return a.add(dir.mult(frac));\r\n    }\r\n\r\n    /**Returns an array of n points spaced equally between points a and b. Eg. if n = 3, points are 1/4 of the way, 1/2 of the way and 3/4 of the way.\r\n     * If includeEnds is true, the array also includes point a at [0], and point b at [last], in that case the length of the return array is n + 2.\r\n     */\r\n    static getPointsBetween(a, b, n, includeEnds)\r\n    {\r\n        const returnArray = [];\r\n        if (includeEnds) {returnArray.push(V2.cloneFrom(a));}\r\n        const fracBase = 1 / (1 + Math.abs(n));\r\n        let frac;\r\n        for(let i = 0; i < n; i++)\r\n        {\r\n            frac = fracBase * (i + 1);\r\n            returnArray.push(V2.getPointBetween(a, b, frac));\r\n        }\r\n        if (includeEnds) {returnArray.push(V2.cloneFrom(b));}\r\n        return returnArray;\r\n    }\r\n\r\n    /**Returns true if this vector is perpendicular to other (angled at 90 degrees). Tolerance is used to determine how precisely the 2 vectors need to be perpendicular for it to be considered true.\r\n     * A value of 0 means only exactly perpendicular vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended.*/\r\n    isPerpendicular(other, tolerance = 0.0001)\r\n    {\r\n        return (Math.abs(V2.normDot(this, other)) <= tolerance);\r\n    }\r\n\r\n    /**Returns true if this vector is paralell to other. Tolerance is used to determine how precisely the 2 vectors need to be paralell for it to be considered true.\r\n     * A value of 0 means only exactly paralell vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended.\r\n    */\r\n    isParallel(other, tolerance = 0.0001)\r\n    {\r\n        return (Math.abs(V2.normDot(this, other) - 1) <= tolerance) || (Math.abs(V2.normDot(this, other) + 1) <= tolerance);\r\n    }\r\n\r\n    /**Returns true if all the vectors passed in are parallel. Tolerance is used to determine how precisely the 2 vectors need to be paralell for it to be considered true.\r\n     * A value of 0 means only exactly paralell vectors will be considered as such. Values in the range of 0.001 to 0.00001 are recommended. If there's no vectors for comparison returns true.\r\n     */\r\n    static areParallel(tolerance = 0.0001, ...vectors)\r\n    {\r\n        if (!vectors || vectors.length < 2){return true;}\r\n        for(let i = 1; i < vectors.length; i++)\r\n        {\r\n            if (!vectors[i - 1].isParallel(vectors[i], tolerance))\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**Returns a new V2 perpendicular to this one. Y axis is always positive and the magnitude is preserved.*/ \r\n    getPerpendicular()\r\n    {\r\n        return (this.x >= 0) ? new V2(-this.y, this.x) : new V2(this.y, -this.x);\r\n    }\r\n\r\n    /**Returns an array of integer points adjacent to this point. Adjacent means north, south, east, west.*/\r\n    getAdj()\r\n    {\r\n        const rounded = this.round();\r\n        return [rounded.add(V2.u), rounded.add(V2.r), rounded.add(V2.d), rounded.add(V2.l)];\r\n    }\r\n\r\n    /**Returns an array of integer points diagonal to this point.*/\r\n    getDiag()\r\n    {\r\n        const rounded = this.round();\r\n        return [rounded.add(new V2(1, 1)), rounded.add(new V2(1, -1)), rounded.add(new V2(-1, -1)), rounded.add(new V2(-1, 1))];\r\n    }\r\n\r\n    /**Returns an array of integer points adjacent and diagonal to this point. */\r\n    getSurrounding()\r\n    {\r\n        const rounded = this.round();\r\n        return [\r\n            rounded.add(V2.u),\r\n            rounded.add(new V2(1, 1)),\r\n            rounded.add(V2.r),\r\n            rounded.add(new V2(1, -1)),\r\n            rounded.add(V2.d),\r\n            rounded.add(new V2(-1, -1)),\r\n            rounded.add(V2.l),\r\n            rounded.add(new V2(-1, 1)),\r\n        ];\r\n    }\r\n\r\n    /**Returns true if this integer point is adjacent to to. Adjacent means north, south, east, west. */\r\n    isAdj(to)\r\n    {\r\n        for(let i = 0; i < V2.adjDirs.length; i++)\r\n        {\r\n            if (this.add(V2.adjDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns true if this integer point is diagonal to to.*/\r\n    isDiag(to)\r\n    {\r\n        for(let i = 0; i < V2.diagDirs.length; i++)\r\n        {\r\n            if (this.add(V2.diagDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns true if this integer point is diagonal or adjacent to to.*/\r\n    isSurr(to)\r\n    {\r\n        for(let i = 0; i < V2.baseDirs.length; i++)\r\n        {\r\n            if (this.add(V2.baseDirs[i]).equal(to))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**Returns a string representation of this vector that looks like this: [x; y] */\r\n    toString()\r\n    {\r\n        return \"[\" + this.x.toString() + \"; \" + this.y.toString() + \"]\";\r\n    }\r\n}\r\n\r\nexport default V2",["109","110"],"D:\\ReactProjects\\lite-lineage\\src\\components\\Notice.jsx",[],{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},{"ruleId":"111","replacedBy":"115"},{"ruleId":"113","replacedBy":"116"},{"ruleId":"117","severity":1,"message":"118","line":13,"column":22,"nodeType":"119","messageId":"120","endLine":13,"endColumn":36},{"ruleId":"121","severity":1,"message":"122","line":75,"column":21,"nodeType":"123","messageId":"124","endLine":75,"endColumn":23},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","replacedBy":"114"},"no-native-reassign",["125"],"no-negated-in-lhs",["126"],["125"],["126"],"no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-global-assign","no-unsafe-negation"]