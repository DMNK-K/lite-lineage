[{"D:\\ReactProjects\\lite-lineage\\src\\index.js":"1","D:\\ReactProjects\\lite-lineage\\src\\App.js":"2","D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js":"3","D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx":"4","D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx":"5","D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx":"6","D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx":"7","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx":"8","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx":"9","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx":"10","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx":"11","D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx":"12","D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js":"13","D:\\ReactProjects\\lite-lineage\\src\\Person.js":"14","D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx":"15","D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx":"16","D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js":"17","D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx":"18","D:\\ReactProjects\\lite-lineage\\src\\Helpers.js":"19","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx":"20","D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx":"21","D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx":"22","D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js":"23"},{"size":500,"mtime":499162500000,"results":"24","hashOfConfig":"25"},{"size":10594,"mtime":1611432684632,"results":"26","hashOfConfig":"25"},{"size":362,"mtime":499162500000,"results":"27","hashOfConfig":"25"},{"size":498,"mtime":1611498369513,"results":"28","hashOfConfig":"25"},{"size":2305,"mtime":1610568177174,"results":"29","hashOfConfig":"25"},{"size":387,"mtime":1611501002785,"results":"30","hashOfConfig":"25"},{"size":3127,"mtime":1611501513125,"results":"31","hashOfConfig":"25"},{"size":9106,"mtime":1611242978479,"results":"32","hashOfConfig":"25"},{"size":3867,"mtime":1611432423577,"results":"33","hashOfConfig":"25"},{"size":612,"mtime":1611498253521,"results":"34","hashOfConfig":"25"},{"size":1139,"mtime":1611498322843,"results":"35","hashOfConfig":"25"},{"size":1397,"mtime":1610649766940,"results":"36","hashOfConfig":"25"},{"size":8604,"mtime":1611159951168,"results":"37","hashOfConfig":"25"},{"size":6896,"mtime":1611498198308,"results":"38","hashOfConfig":"25"},{"size":12494,"mtime":1611498104796,"results":"39","hashOfConfig":"25"},{"size":1850,"mtime":1611498297626,"results":"40","hashOfConfig":"25"},{"size":296,"mtime":1611498484830,"results":"41","hashOfConfig":"25"},{"size":5468,"mtime":1611498272986,"results":"42","hashOfConfig":"25"},{"size":2694,"mtime":1611497164361,"results":"43","hashOfConfig":"25"},{"size":3205,"mtime":1611495263805,"results":"44","hashOfConfig":"25"},{"size":260,"mtime":1611498417865,"results":"45","hashOfConfig":"25"},{"size":1076,"mtime":1611438985631,"results":"46","hashOfConfig":"25"},{"size":14215,"mtime":1611494936093,"results":"47","hashOfConfig":"48"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},"19gfp4v",{"filePath":"52","messages":"53","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"51"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"67","usedDeprecatedRules":"51"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"78","usedDeprecatedRules":"51"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"81","messages":"82","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"89","messages":"90","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"51"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"16qv85j","D:\\ReactProjects\\lite-lineage\\src\\index.js",[],["99","100"],"D:\\ReactProjects\\lite-lineage\\src\\App.js",["101","102","103","104","105"],"// import logo from './logo.svg';\nimport './App.css';\nimport Header from './components/Header';\nimport Footer from './components/Footer';\nimport Content from './components/Content';\nimport React, { Component } from 'react';\n// import Cookies from 'js-cookies';\nimport FamilyTree from './FamilyTree';\nimport Person from './Person';\nimport TreeContext from './TreeContext';\n\nclass App extends Component\n{\n  constructor(props)\n  {\n      super(props);\n      this.state = {\n        treeNames: this.loadTreeNames(), //array of treeNames\n        isInTree: false,\n        currentTree: null //null when none loaded, otherwise an instance of FamilyTree class\n      }\n      this.handleWindowClose = this.handleWindowClose.bind(this);\n\n      this.handleNewTree = this.handleNewTree.bind(this);\n      this.handleImportTree = this.handleImportTree.bind(this);\n      this.handleDeleteTree = this.handleDeleteTree.bind(this);\n      this.handleExitTree = this.handleExitTree.bind(this);\n      this.handleRenameTree = this.handleRenameTree.bind(this);\n      this.handleOpenTree = this.handleOpenTree.bind(this);\n      \n      this.handleAddFamMember = this.handleAddFamMember.bind(this);\n      this.handleDeleteFamMember = this.handleDeleteFamMember.bind(this);\n      this.handleEditFamMember = this.handleEditFamMember.bind(this);\n      this.handleEditFamMembers = this.handleEditFamMembers.bind(this);\n\n      this.treeHandlers = {\n        handleNewTree: this.handleNewTree,\n        handleDeleteTree: this.handleDeleteTree,\n        handleExitTree: this.handleExitTree,\n        handleRenameTree: this.handleRenameTree,\n        handleOpenTree: this.handleOpenTree,\n        handleImportTree: this.handleImportTree,\n      };\n\n      //similar thing with this:\n      this.familyHandlers = {\n        handleAddFamMember: this.handleAddFamMember,\n        handleDeleteFamMember: this.handleDeleteFamMember,\n        handleEditFamMember: this.handleEditFamMember,\n        handleEditFamMembers: this.handleEditFamMembers,\n      };\n  }\n\n  componentDidMount()\n  {\n    window.addEventListener(\"beforeunload\", this.handleWindowClose);\n  }\n\n  componentWillUnmount()\n  {\n    window.removeEventListener(\"beforeunload\", this.handleWindowClose);\n  }\n\n  handleWindowClose()\n  {\n    if (this.state.isInTree)\n    {\n      this.state.currentTree.save();\n    }\n  }\n\n  loadTreeNames()\n  {\n    const namesStr = localStorage.getItem(\"treeNames\");\n    const separator = \"~\";\n    if (namesStr)\n    {\n      return namesStr.split(separator).filter(str => str !== \"\");\n    }\n    else\n    {\n      return [];\n    }\n  }\n\n  saveTreeNames()\n  {\n    localStorage.setItem(\"treeNames\", this.state.treeNames.join(\"~\"));\n    //console.log(\"saved, \" + this.state.treeNames.toString());\n  }\n\n  loadTree(treeName)\n  {\n    if (treeName)\n    {\n      const loadedTreeStr = localStorage.getItem(treeName);\n      if (loadedTreeStr)\n      {\n        const treeObj = new FamilyTree(treeName, Date(), []);\n        treeObj.fillDataFromJSON(loadedTreeStr);\n        return treeObj;\n      }\n      else\n      {\n        console.error(\"Loading tree \" + treeName + \" failed, string from localStorage is falsey.\");\n        return null;\n      }\n    }\n    else\n    {\n      console.error(\"Loading tree \" + treeName + \" failed, this name is falsey.\");\n      return null;\n    }\n  }\n\n  handleNewTree()\n  {\n    //console.log(\"trying to make tree\");\n    const newName = FamilyTree.makeNewName(this.state.treeNames);\n    const newTree = new FamilyTree(newName, Date(), []);\n    this.setState({\n      treeNames: [...this.state.treeNames, newName],\n      currentTree: newTree,\n      isInTree: true\n    }, () => {\n        this.saveTreeNames();\n        newTree.save();\n        // console.log(this.state);\n      }\n    );\n  }\n\n  handleImportTree(importedTree)\n  {\n    //imported tree might have a name identical to exisitng one, need to account for that\n    let i = 1;\n    const originalName = importedTree.treeName;\n    while (this.state.treeNames.includes(importedTree.treeName))\n    {\n      importedTree.treeName = originalName + \" \" + i;\n      i++;\n    }\n    const newTreeNames = [...this.state.treeNames, importedTree.treeName];\n    importedTree.save();\n    this.setState({treeNames: newTreeNames});\n  }\n\n  handleDeleteTree(nameOfTreeToDelete)\n  {\n    //console.log(\"trying to delete \" + nameOfTreeToDelete);\n    localStorage.removeItem(nameOfTreeToDelete);\n    this.setState(\n      {\n        treeNames: this.state.treeNames.filter(item => item !== nameOfTreeToDelete)\n      },\n      () => {\n        this.saveTreeNames();\n        //console.log(this.state);\n      }\n    );\n  }\n\n  handleRenameTree(oldTreeName, newTreeName)\n  {\n    if (oldTreeName === newTreeName || this.state.currentTree.treeName !== oldTreeName || !this.state.treeNames.includes(oldTreeName) || this.state.treeNames.includes(newTreeName))\n    {\n      // console.log(\"handleRenameTree was ignored.\");\n      return;\n    }\n\n    const newTreeNames = [...this.state.treeNames];\n    const i = newTreeNames.indexOf(oldTreeName);\n    if (i >= 0)\n    {\n      newTreeNames[i] = newTreeName;\n\n      const copyOfCurrentTree = FamilyTree.cloneFromOther(this.state.currentTree);\n      copyOfCurrentTree.treeName = newTreeName;\n      this.setState(\n        {\n          treeNames: newTreeNames,\n          currentTree: copyOfCurrentTree\n        },\n        () => {\n          this.saveTreeNames();\n          this.state.currentTree.save();\n        }\n      );\n    }\n  }\n\n  handleOpenTree(treeName)\n  {\n    const loaded = this.loadTree(treeName);\n    if (loaded !== null)\n    {\n      this.setState({\n        currentTree: loaded,\n        isInTree: true\n      });\n    }\n  }\n\n  handleExitTree()\n  {\n    this.state.currentTree.save();\n    this.setState({\n      currentTree: null,\n      isInTree: false\n    });\n  }\n\n  handleAddFamMember(mode = \"default\", anchorPersonId)\n  {\n    if (!this.state.currentTree){return;}\n    const viableModes = [\"default\", \"parent\", \"child\"];\n    if (!viableModes.includes(mode))\n    {\n      console.error(\"Invalid mode of adding a family member.\");\n      return;\n    }\n    const newId = this.state.currentTree.findLowestUnusedFamilyMemberId();  \n    const newPerson = new Person(newId);\n    const anchorPersonIndex = this.state.currentTree.family.findIndex(item => item.id == anchorPersonId);\n    let draftAnchorPerson = null;\n    if (anchorPersonIndex >= 0) {draftAnchorPerson = Person.cloneFromOther(this.state.currentTree.family[anchorPersonIndex]);}\n\n    let loc = FamilyTree.minFamilyMemberLocation;\n    //doing mode specific things\n    if (anchorPersonId !== undefined && anchorPersonId >= 0)\n    {\n      if(mode === \"parent\")\n      {\n        draftAnchorPerson?.addParentId(newId);\n        loc = this.state.currentTree.findFreeLocationUpwards(anchorPersonId, 4, 2);\n      }\n      else if(mode === \"child\")\n      {\n        newPerson.addParentId(anchorPersonId);\n        loc = this.state.currentTree.findFreeLocationDownwards(anchorPersonId, 4, 2);\n      }\n      else\n      {\n        loc = this.state.currentTree.findFreeLocationNearby(anchorPersonId, 4, 2, 100, 100);\n      }\n    }\n    newPerson.locationInTreeX = loc.x;\n    newPerson.locationInTreeY = loc.y;\n    //we can get away with just spreading old family, since those people inside won't be mutated anyway\n    let draftFamily = [...this.state.currentTree.family, newPerson];\n    if (draftAnchorPerson && anchorPersonIndex >= 0) {draftFamily[anchorPersonIndex] = draftAnchorPerson;}\n    //if the new person's location is below the tree's minimum, the entire family is shifted to accomodate the new person\n    if (FamilyTree.isFamilyMemberLocationBelowMin(loc))\n    {\n      draftFamily = FamilyTree.shiftFamilyImmutably(draftFamily, FamilyTree.getShiftVector(loc));\n    }\n    const draftTree = FamilyTree.cloneFromOther(this.state.currentTree);\n    draftTree.family = draftFamily;\n    // console.log(draftAnchorPerson);\n    this.setState(\n      {\n        currentTree: draftTree,\n      },\n      () => {\n        this.state.currentTree.save();\n        // console.log(this.state.currentTree.family[anchorPersonIndex]);\n        // console.log(this.state.currentTree.family.length);\n      }\n    );\n  }\n\n  handleEditFamMember(personId, replacerPersonObj)\n  {\n    //edited data should already be validated before it gets here\n    //console.log(\"handling edit of person with id: \" + personId + \" (should match this one: \"+ replacerPersonObj.id +\")\");\n    let newFamily = [...this.state.currentTree.family];\n    const i = newFamily.findIndex(item => item.id == personId);\n    if (i >= 0)\n    {\n      newFamily[i] = replacerPersonObj;\n      if (FamilyTree.isFamilyMemberLocationBelowMin(replacerPersonObj.getLocation()))\n      {\n        const vector = FamilyTree.getShiftVector(replacerPersonObj.getLocation());\n        newFamily = FamilyTree.shiftFamilyImmutably(newFamily, vector);\n      }\n      const draftTree = FamilyTree.cloneFromOther(this.state.currentTree);\n      draftTree.family = newFamily;\n      this.setState(\n        {\n          currentTree: draftTree,\n        },\n        () => {\n          this.state.currentTree.save();\n          // console.log(this.state.currentTree.family[i]);\n        }\n      );\n    }\n  }\n\n  handleEditFamMembers(personIds, replacerPersonObjs)\n  {\n    if (personIds.length != replacerPersonObjs.length){return;}\n    console.log(\"trying to change multiple fam members\");\n    const newFamily = [...this.state.currentTree.family];\n    for(let i = 0; i < personIds.length; i++)\n    {\n      const index = newFamily.findIndex(item => item.id == personIds[i]);\n      if (index >= 0)\n      {\n        newFamily[index] = replacerPersonObjs[i];\n      }\n    }\n    const draftTree = FamilyTree.cloneFromOther(this.state.currentTree);\n    draftTree.family = newFamily;\n    this.setState(\n      {\n        currentTree: draftTree,\n      },\n      () => {this.state.currentTree.save();}\n    );\n  }\n\n  handleDeleteFamMember(personId)\n  {\n    const newFamily = [...this.state.currentTree.family];\n    const i = newFamily.findIndex(item => item.id == personId);\n    if (i >= 0)\n    {\n      newFamily.splice(i, 1);\n      const draftTree = FamilyTree.cloneFromOther(this.state.currentTree);\n      draftTree.family = newFamily;\n      this.setState(\n        {\n          currentTree: draftTree,\n        },\n        () => {this.state.currentTree.save();}\n      );\n    }\n  }\n\n  render()\n  {\n    return (\n      <TreeContext.Provider className=\"app\" value={{...this.state, treeHandlers: this.treeHandlers, familyHandlers: this.familyHandlers}}>\n        <Header/>\n        <Content/>\n        <Footer/>\n      </TreeContext.Provider>\n    );\n  }\n}\n\nexport default App;","D:\\ReactProjects\\lite-lineage\\src\\reportWebVitals.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Content.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Header.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\Footer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\StartView.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyView.jsx",["106","107","108","109","110","111"],"import React, { Component } from 'react';\r\nimport SideDrawer from './SideDrawer';\r\nimport FamilyMember from './FamilyMember';\r\nimport SideDrawerEditMemberForm from './SideDrawerEditMemberForm';\r\nimport '../App.css';\r\nimport TreeContext from '../TreeContext';\r\nimport Person from '../Person';\r\nimport Helpers from '../Helpers';\r\nimport ConnectionRenderer from './ConnectionRenderer';\r\nimport FamilyConnection from './FamilyConnection';\r\n\r\nclass FamilyView extends Component\r\n{\r\n    static contextType = TreeContext;\r\n    #zoomMin = 0;\r\n    #zoomMax = 4;\r\n    #locationScalesByZoom = [20, 30, 40, 60, 80];\r\n    #lineCenteringOffsetByZoom = [\r\n        {x: 40, y: 20},\r\n        {x: 60, y: 30},\r\n        {x: 80, y: 40},\r\n        {x: 120, y: 60},\r\n        {x: 160, y: 80}\r\n    ];\r\n\r\n    constructor(props)\r\n    {\r\n        super(props);\r\n        this.state = {\r\n            editingPerson: false,\r\n            editedPersonId: null,\r\n            zoomLvl: 2,\r\n            locationScale: 40,\r\n            stretcherOverhead: {x: 7, y: 5},\r\n            isDragging: false,\r\n            draggedId: null,\r\n            lineCenteringOffset: {x: 80, y: 40},\r\n        }\r\n        this.startEdit = this.startEdit.bind(this);\r\n        this.reportDeletionToEdit = this.reportDeletionToEdit.bind(this);\r\n        this.endEdit = this.endEdit.bind(this);\r\n        this.startDrag = this.startDrag.bind(this);\r\n        this.tryDrag = this.tryDrag.bind(this);\r\n        this.endDrag = this.endDrag.bind(this);\r\n        this.zoom = this.zoom.bind(this);\r\n    }\r\n\r\n    startEdit(personId)\r\n    {\r\n        this.setState({editingPerson: true, editedPersonId: personId});\r\n    }\r\n\r\n    reportDeletionToEdit(personId)\r\n    {\r\n        if (this.state.editingPerson === true && this.state.editedPersonId != null && personId == this.state.editedPersonId)\r\n        {\r\n            this.endEdit();\r\n        }\r\n    }\r\n\r\n    endEdit()\r\n    {\r\n        this.setState({editingPerson: false, editedPersonId: null});\r\n    }\r\n\r\n    startDrag(personId)\r\n    {\r\n        // console.log(\"starting drag\");\r\n        this.setState({isDragging: true, draggedId: personId});\r\n    }\r\n\r\n    componentDidMount()\r\n    {\r\n        window.addEventListener(\"mouseup\", this.endDrag);\r\n    }\r\n\r\n    componentWillUnmount()\r\n    {\r\n        window.removeEventListener(\"mouseup\", this.endDrag);\r\n    }\r\n\r\n    tryDrag(e, referenceElement)\r\n    {\r\n        //this was the only solution that calculated coords correctly, but it needs a ref element passed somehow\r\n        const offset = Helpers.getRelativeCoords(e.nativeEvent, referenceElement);\r\n        // console.log(\"dragging \"+ this.state.draggedId +\" to [\" + offset.x + \", \" + offset.y + \"]\");\r\n        if (this.state.isDragging === true && this.state.draggedId != null && this.state.draggedId >= 0)\r\n        {\r\n            const newLocation = this.calcLocationFromOffset(offset);\r\n            const i = this.context.currentTree.family.findIndex(item => item.id == this.state.draggedId);\r\n            const draftPerson = Person.cloneFromOther(this.context.currentTree.family[i]);\r\n            // console.log(\"new location: [\" + newLocation.x + \", \" + newLocation.y + \"]\");\r\n            draftPerson.locationInTreeX = newLocation.x;\r\n            draftPerson.locationInTreeY = newLocation.y;\r\n            this.context.familyHandlers.handleEditFamMember(this.state.draggedId, draftPerson);\r\n        }\r\n    }\r\n\r\n    endDrag()\r\n    {\r\n        // console.log(\"ending drag\");\r\n        this.setState({isDragging: false, draggedId: null});\r\n    }\r\n\r\n    calcLocationFromOffset(offset)\r\n    {\r\n        return {\r\n            x: Math.round(offset.x / this.state.locationScale),\r\n            y: Math.round(offset.y / this.state.locationScale)\r\n        };\r\n    }\r\n\r\n    calcCssSizeOfConnectionRenderer()\r\n    {\r\n        //bounds of the tree incremented by 2 in both axis, so the line renderer also acts as a stretcher\r\n        //for the whole area of the tree\r\n        const bounds = this.context.currentTree.getBounds(this.state.stretcherOverhead.x, this.state.stretcherOverhead.y);\r\n        return {\r\n            width: (bounds.x * this.state.locationScale) + \"px\",\r\n            height: (bounds.y * this.state.locationScale) + \"px\"\r\n        };\r\n    }\r\n\r\n    zoom(dir)\r\n    {\r\n        if (dir == 0){return;}\r\n        dir = (dir > 0) ? 1 : -1;\r\n        this.setState((prevState, props) => (\r\n            {\r\n                zoomLvl: prevState.zoomLvl + dir,\r\n                locationScale: this.#locationScalesByZoom[prevState.zoomLvl + dir],\r\n                lineCenteringOffset: this.#lineCenteringOffsetByZoom[prevState.zoomLvl + dir]\r\n            }\r\n        ));\r\n    }\r\n    \r\n    render()\r\n    {\r\n        const familyMembers = this.context.currentTree.family.map((member) =>\r\n            <FamilyMember\r\n                key={member.id}\r\n                person={member}\r\n                familyHandlers={this.context.familyHandlers}\r\n                reportDeletionToEdit={this.reportDeletionToEdit}\r\n                startEdit={this.startEdit}\r\n                locationScale={this.state.locationScale}\r\n                zoomLvl={this.state.zoomLvl}\r\n                startDrag={this.startDrag}\r\n            />\r\n        );\r\n\r\n        //finding people taking part in a connection\r\n        const connectionMembers = [];\r\n        const establishedParentIdPairs = [];\r\n        for (let i = 0; i < this.context.currentTree.family.length; i++)\r\n        {\r\n            const b = this.context.currentTree.family[i];\r\n            const parents = b.getCurrentParents(this.context.currentTree.family);\r\n            if (parents[0] || parents[1])\r\n            {\r\n                //there is a connection that exists for b\r\n                connectionMembers.push({\r\n                    a1: parents[0],\r\n                    a2: parents[1],\r\n                    b: b\r\n                });\r\n\r\n                if (parents[0] && parents[1])\r\n                {\r\n                    //check if this parent pair was already established (checking both orders of being saved since they might differ in different child)\r\n                    //we're doing it in order not to duplicate connections that are suppoosed to represent relationships between 2 people that had children together\r\n                    //since they are distinct from the child-parent connections \r\n                    if (!establishedParentIdPairs.includes(parents[0].id + \"_\" + parents[1].id) && !establishedParentIdPairs.includes(parents[1].id + \"_\" + parents[0].id))\r\n                    {\r\n                        connectionMembers.push({\r\n                            a1: parents[0],\r\n                            a2: parents[1],\r\n                            b: null\r\n                        });\r\n                        establishedParentIdPairs.push(parents[0].id + \"_\" + parents[1].id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const connections = connectionMembers.map((connectionMember) =>\r\n            <FamilyConnection\r\n                key={connectionMember.a1?.id + \"_\" + connectionMember.a2?.id + \"|\" + connectionMember.b?.id}\r\n                personA1={connectionMember.a1}\r\n                personA2={connectionMember.a2}\r\n                personB={connectionMember.b}\r\n                locationScale={this.state.locationScale}\r\n                lineCenteringOffset={this.state.lineCenteringOffset}\r\n            />\r\n        );\r\n\r\n        const editedPersonIndex = this.context.currentTree.family.findIndex(item => item.id == this.state.editedPersonId);\r\n        const editedPerson = (editedPersonIndex >= 0) ? this.context.currentTree.family[editedPersonIndex] : null;\r\n\r\n        const sideDrawer = (\r\n            <SideDrawer\r\n                name=\"Editing...\"\r\n                content={\r\n                    <SideDrawerEditMemberForm\r\n                        editedPerson={editedPerson}\r\n                        handleEdit={this.context.familyHandlers.handleEditFamMember}\r\n                        handleEditMultiple={this.context.familyHandlers.handleEditFamMembers}\r\n                        family={this.context.currentTree.family}\r\n                    />}\r\n                closeAction={this.endEdit}\r\n            />\r\n        );\r\n\r\n        return (\r\n            <div className=\"family_view\">\r\n                {this.state.editingPerson === true && sideDrawer}\r\n                <div className=\"zoom_wrapper\">\r\n                    <button onClick={this.zoom.bind(this, 1)} disabled={this.state.zoomLvl == this.#zoomMax}>+</button>\r\n                    <button onClick={this.zoom.bind(this, -1)} disabled={this.state.zoomLvl == this.#zoomMin}>-</button>\r\n                </div>\r\n                <div id=\"family_tree\" className=\"family_tree\" onMouseMove={this.state.isDragging ? (e) => this.tryDrag(e, document.getElementById(\"family_tree\")) : undefined}>\r\n                    {familyMembers}\r\n                    <ConnectionRenderer style={this.calcCssSizeOfConnectionRenderer()}>\r\n                        {connections}\r\n                    </ConnectionRenderer>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default FamilyView;","D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMember.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyMemberExtension.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\NavInFamily.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\FamilyTree.js",["112","113","114"],"import Person from './Person';\r\n\r\nclass FamilyTree\r\n{\r\n    static minFamilyMemberLocation = {x: 1, y: 1};\r\n\r\n    treeName;\r\n    creationDate;\r\n    family = []; //array of instances of Person class\r\n\r\n    constructor(treeName, creationDate, family)\r\n    {\r\n        this.treeName = treeName;\r\n        this.creationDate = creationDate;\r\n        this.family = family;\r\n    }\r\n\r\n    static makeNewName(takenNames)\r\n    {\r\n        let newName = \"My Tree 1\";\r\n        let i = 1;\r\n        while (takenNames.includes(newName))\r\n        {\r\n            i++;\r\n            newName = \"My Tree \" + i;\r\n        }\r\n        return newName;\r\n    }\r\n\r\n    static isFamilyMemberLocationBelowMin(location)\r\n    {\r\n        return (location.x < this.minFamilyMemberLocation.x || location.y < this.minFamilyMemberLocation.y);\r\n    }\r\n\r\n    static getShiftVector(location)\r\n    {\r\n        const x = (location.x < this.minFamilyMemberLocation.x) ? this.minFamilyMemberLocation.x - location.x : 0;\r\n        const y = (location.y < this.minFamilyMemberLocation.y) ? this.minFamilyMemberLocation.y - location.y : 0;\r\n        return {x: x, y: y};\r\n    }\r\n\r\n    static shiftFamily(family, vector)\r\n    {\r\n        for(let i = 0; i < family.length; i++)\r\n        {\r\n            family[i].locationInTreeX += vector.x;\r\n            family[i].locationInTreeY += vector.y;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Shifts location of all members of a provided family by a vector.\r\n     * This returns a new array and also its contents are clones, to provide immutability for react.\r\n     */\r\n    static shiftFamilyImmutably(family, vector)\r\n    {\r\n        const newFam = [];\r\n        let draft;\r\n        for(let i = 0; i < family.length; i++)\r\n        {\r\n            draft = Person.cloneFromOther(family[i]);\r\n            draft.locationInTreeX += vector.x;\r\n            draft.locationInTreeY += vector.y;\r\n            newFam.push(draft);\r\n        }\r\n        return newFam;\r\n    }\r\n\r\n    fillDataFromJSON(unparsedJson)\r\n    {\r\n        this.fillDataFromParsedJSON(JSON.parse(unparsedJson));\r\n    }\r\n\r\n    fillDataFromParsedJSON(parsedJsonObj)\r\n    {\r\n        //used for loading family trees from JSON files\r\n        //the way you would use it is you first create an instance of FamilyTree,\r\n        //then you call this to fill in data, where parsedJsonObj is something JSON.parse() returns\r\n        //this is done (instead of only using the constructor) to preserve instance functions,\r\n        //since JSON.stringify() drops them\r\n        this.treeName = parsedJsonObj.treeName;\r\n        this.creationDate = parsedJsonObj.creationDate;\r\n        this.family.length = 0;\r\n        for(let i = 0; i < parsedJsonObj.family.length; i++)\r\n        {\r\n            const personObj = new Person(parsedJsonObj.family[i].id);\r\n            personObj.fillDataFromParsedJSON(parsedJsonObj.family[i]);\r\n            this.family.push(personObj);\r\n        }\r\n    }\r\n\r\n    fillDataFromOther(otherTree)\r\n    {\r\n        this.treeName = otherTree.treeName;\r\n        this.creationDate = otherTree.creationDate;\r\n        this.family = otherTree.family;\r\n    }\r\n\r\n    findLowestUnusedFamilyMemberId()\r\n    {\r\n        let newId = -1;\r\n        let idExists = true;\r\n        while (idExists)\r\n        {\r\n            newId++;\r\n            idExists = false;\r\n            for(let i = 0; i < this.family.length; i++)\r\n            {\r\n                if (newId == this.family[i].id) {idExists = true;}\r\n            }\r\n        }\r\n        return newId;\r\n    }\r\n\r\n    static cloneFromOther(otherTree)\r\n    {\r\n        return new FamilyTree(otherTree.treeName, otherTree.creationDate, [...otherTree.family]);\r\n    }\r\n\r\n    save()\r\n    {\r\n        localStorage.setItem(this.treeName, JSON.stringify(this));\r\n    }\r\n\r\n    findFreeLocationUpwards(idOfRefPerson, marginX, marginY)\r\n    {\r\n        //upwards dir is -1 since coords are counted from top\r\n        return this.findFreeLocationVertically(idOfRefPerson, marginX, marginY, -1, true, marginX + 1);\r\n    }\r\n\r\n    findFreeLocationDownwards(idOfRefPerson, marginX, marginY)\r\n    {\r\n        return this.findFreeLocationVertically(idOfRefPerson, marginX, marginY, 1, true, marginX + 1);\r\n    }\r\n\r\n    findFreeLocationVertically(idOfRefPerson, marginX, marginY, dir, checkPerifery, periferyRange)\r\n    {\r\n        const i = this.family.findIndex(item => item.id == idOfRefPerson);\r\n        if (i < 0) {return null;}\r\n        const refPerson =  this.family[i];\r\n        const searchRangeY = 100 + marginY;\r\n        for(let i = marginY + 1; i < searchRangeY; i++)\r\n        {\r\n            const y = (dir > 0) ? refPerson.locationInTreeY + i : refPerson.locationInTreeY - i;\r\n            if (this.isLocationFree(refPerson.locationInTreeX, y, marginX, marginY))\r\n            {\r\n                return {x: refPerson.locationInTreeX, y: y};\r\n            }\r\n            //now check perifery a bit to left and right\r\n            if (checkPerifery)\r\n            {\r\n                if (this.isLocationFree(refPerson.locationInTreeX - periferyRange, y, marginX, marginY))\r\n                {\r\n                    return {x: refPerson.locationInTreeX - periferyRange, y: y};\r\n                }\r\n                if (this.isLocationFree(refPerson.locationInTreeX + periferyRange, y, marginX, marginY))\r\n                {\r\n                    return {x: refPerson.locationInTreeX + periferyRange, y: y};\r\n                }\r\n            }\r\n        }\r\n        return {x: 0, y: 0}; //fallback\r\n    }\r\n\r\n    findFreeLocationNearby(idOfRefPerson, marginX, marginY, rangeX, rangeY)\r\n    {\r\n        //searches first to the sides, then moves up or down, first favouring down\r\n        const i = this.family.findIndex(item => item.id == idOfRefPerson);\r\n        if (i < 0) {return null;}\r\n        const refPerson =  this.family[i];\r\n        const searchRangeX = rangeX + marginX;\r\n        const searchRangeY = rangeY + marginY;\r\n        let x;\r\n        //to the sides:\r\n        for(let i = marginX + 1; i < searchRangeX; i++)\r\n        {\r\n            x = refPerson.locationInTreeX - i;\r\n            if (this.isLocationFree(x, refPerson.locationInTreeY, marginX, marginY))\r\n            {\r\n                return {x: x, y: refPerson.locationInTreeY};\r\n            }\r\n            x = refPerson.locationInTreeX + i;\r\n            if (this.isLocationFree(x, refPerson.locationInTreeY, marginX, marginY))\r\n            {\r\n                return {x: x, y: refPerson.locationInTreeY};\r\n            }\r\n        }\r\n        //up and down alternating, with down first, to the sides, proioritizing left\r\n        let y;\r\n        for(let i = marginY + 1; i < searchRangeY; i++)\r\n        {\r\n            for(let q = marginX + 1; q < searchRangeX; q++)\r\n            {\r\n                y = refPerson.locationInTreeY + i;\r\n                x = refPerson.locationInTreeX - q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                x = refPerson.locationInTreeX + q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                y = refPerson.locationInTreeY - i;\r\n                x = refPerson.locationInTreeX - q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n                x = refPerson.locationInTreeX + q;\r\n                if (this.isLocationFree(x, y, marginX, marginY)) { return {x: x, y: y};}\r\n            }\r\n        }\r\n        return {x: 0, y: 0}; //fallback\r\n    }\r\n\r\n    isLocationFree(x, y, marginX, marginY)\r\n    {\r\n        const minX = x - marginX;\r\n        const minY = y - marginY;\r\n        const maxX = x + marginX;\r\n        const maxY = y + marginY;\r\n        for(let i = 0; i < this.family.length; i++)\r\n        {\r\n            if (this.family[i].locationInTreeX >= minX && this.family[i].locationInTreeX <= maxX && this.family[i].locationInTreeY >= minY && this.family[i].locationInTreeY <= maxY)\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get maximal locations of family members in this tree, both in x and y axis. Can be stretched by overhead.\r\n     */\r\n    getBounds(overheadX = 0, overheadY = 0)\r\n    {\r\n        const bounds = {x: 0, y: 0};\r\n        for(let i = 0; i < this.family.length; i++)\r\n        {\r\n            if (this.family[i].locationInTreeX > bounds.x) {bounds.x = this.family[i].locationInTreeX;}\r\n            if (this.family[i].locationInTreeY > bounds.y) {bounds.y = this.family[i].locationInTreeY;}\r\n        }\r\n        bounds.x += overheadX;\r\n        bounds.y += overheadY;\r\n        return bounds;\r\n    }\r\n}\r\n\r\nexport default FamilyTree;","D:\\ReactProjects\\lite-lineage\\src\\Person.js",["115","116","117","118","119","120","121","122"],"D:\\ReactProjects\\lite-lineage\\src\\components\\SideDrawerEditMemberForm.jsx",["123","124"],"D:\\ReactProjects\\lite-lineage\\src\\components\\StartTreeButton.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\TreeContext.js",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SpecialDateInput.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\Helpers.js",["125","126","127"],"D:\\ReactProjects\\lite-lineage\\src\\components\\FamilyConnection.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\ConnectionRenderer.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\components\\SelectParent.jsx",[],"D:\\ReactProjects\\lite-lineage\\src\\geo\\V2.js",["128","129"],{"ruleId":"130","replacedBy":"131"},{"ruleId":"132","replacedBy":"133"},{"ruleId":"134","severity":1,"message":"135","line":224,"column":87,"nodeType":"136","messageId":"137","endLine":224,"endColumn":89},{"ruleId":"134","severity":1,"message":"135","line":277,"column":51,"nodeType":"136","messageId":"137","endLine":277,"endColumn":53},{"ruleId":"134","severity":1,"message":"138","line":302,"column":26,"nodeType":"136","messageId":"137","endLine":302,"endColumn":28},{"ruleId":"134","severity":1,"message":"135","line":307,"column":57,"nodeType":"136","messageId":"137","endLine":307,"endColumn":59},{"ruleId":"134","severity":1,"message":"135","line":326,"column":51,"nodeType":"136","messageId":"137","endLine":326,"endColumn":53},{"ruleId":"134","severity":1,"message":"135","line":55,"column":96,"nodeType":"136","messageId":"137","endLine":55,"endColumn":98},{"ruleId":"134","severity":1,"message":"135","line":90,"column":81,"nodeType":"136","messageId":"137","endLine":90,"endColumn":83},{"ruleId":"134","severity":1,"message":"135","line":126,"column":17,"nodeType":"136","messageId":"137","endLine":126,"endColumn":19},{"ruleId":"134","severity":1,"message":"135","line":197,"column":93,"nodeType":"136","messageId":"137","endLine":197,"endColumn":95},{"ruleId":"134","severity":1,"message":"135","line":218,"column":92,"nodeType":"136","messageId":"137","endLine":218,"endColumn":94},{"ruleId":"134","severity":1,"message":"135","line":219,"column":93,"nodeType":"136","messageId":"137","endLine":219,"endColumn":95},{"ruleId":"134","severity":1,"message":"135","line":109,"column":27,"nodeType":"136","messageId":"137","endLine":109,"endColumn":29},{"ruleId":"134","severity":1,"message":"135","line":138,"column":57,"nodeType":"136","messageId":"137","endLine":138,"endColumn":59},{"ruleId":"134","severity":1,"message":"135","line":168,"column":57,"nodeType":"136","messageId":"137","endLine":168,"endColumn":59},{"ruleId":"134","severity":1,"message":"135","line":123,"column":25,"nodeType":"136","messageId":"137","endLine":123,"endColumn":27},{"ruleId":"134","severity":1,"message":"135","line":123,"column":64,"nodeType":"136","messageId":"137","endLine":123,"endColumn":66},{"ruleId":"134","severity":1,"message":"135","line":123,"column":98,"nodeType":"136","messageId":"137","endLine":123,"endColumn":100},{"ruleId":"134","severity":1,"message":"135","line":124,"column":30,"nodeType":"136","messageId":"137","endLine":124,"endColumn":32},{"ruleId":"134","severity":1,"message":"135","line":125,"column":30,"nodeType":"136","messageId":"137","endLine":125,"endColumn":32},{"ruleId":"134","severity":1,"message":"135","line":140,"column":53,"nodeType":"136","messageId":"137","endLine":140,"endColumn":55},{"ruleId":"134","severity":1,"message":"135","line":141,"column":53,"nodeType":"136","messageId":"137","endLine":141,"endColumn":55},{"ruleId":"134","severity":1,"message":"135","line":173,"column":47,"nodeType":"136","messageId":"137","endLine":173,"endColumn":49},{"ruleId":"134","severity":1,"message":"135","line":94,"column":25,"nodeType":"136","messageId":"137","endLine":94,"endColumn":27},{"ruleId":"134","severity":1,"message":"135","line":94,"column":45,"nodeType":"136","messageId":"137","endLine":94,"endColumn":47},{"ruleId":"134","severity":1,"message":"135","line":7,"column":37,"nodeType":"136","messageId":"137","endLine":7,"endColumn":39},{"ruleId":"134","severity":1,"message":"138","line":7,"column":59,"nodeType":"136","messageId":"137","endLine":7,"endColumn":61},{"ruleId":"134","severity":1,"message":"135","line":7,"column":82,"nodeType":"136","messageId":"137","endLine":7,"endColumn":84},{"ruleId":"139","severity":1,"message":"140","line":13,"column":22,"nodeType":"141","messageId":"142","endLine":13,"endColumn":36},{"ruleId":"134","severity":1,"message":"135","line":75,"column":21,"nodeType":"136","messageId":"137","endLine":75,"endColumn":23},"no-native-reassign",["143"],"no-negated-in-lhs",["144"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","no-prototype-builtins","Do not access Object.prototype method 'hasOwnProperty' from target object.","CallExpression","prototypeBuildIn","no-global-assign","no-unsafe-negation"]